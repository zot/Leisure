############
# LOGIC
############

true = \a b . a
false = \a b . b
not b = b false true
and a b = a b false
or a b = a true b
some x = \someCase noneCase . someCase x
some2 a b = \someCase noneCase . someCase a b
none = \someCase noneCase . noneCase
isNone obj = hasType obj none
isSome obj = hasType obj some
isSome2 obj = hasType obj some2
neq a b = not (eq a b)
left x = \lCase rCase . lCase x
right x = \lCase rCase . rCase x

######################
# STRING TYPE CHECKS
######################

strAsc string = _strAsc (assertType 'strAsc string' '*string' string)
strChr ascii = _strChr (assertType 'strChr string' '*number' ascii)
strAt string index = _strAt
  assertType 'strAt string' '*string' string
  assertType 'strAt index' '*number' index
strStartsWith string prefix = _strStartsWith
  assertType 'strStartsWith string' '*string' string
  assertType 'strStartsWith prefix' '*string' prefix
strLen string = _strLen (assertType 'strLen string' '*string' string)
strToLowerCase string = _strToLowerCase (assertType 'strToLowerCase string' '*string' string)
strToUpperCase string = _strToUpperCase (assertType 'strToUpperCase string' '*string' string)
strReplace string pat repl = _strReplace
  assertType 'strReplace string' '*string' string
  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strStartsWith pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat
  assertType 'strReplace repl' '*string' repl
strSubstring str start end = _strSubstring
  assertType 'strSubstring str' '*string' str
  assertType 'strSubstring start' '*number' start
  assertType 'strSubstring end' '*number' end
strSplit str pat = _strSplit
  assertType 'strSplit str' '*string' str
  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strSplit pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat
strCat list = _strCat
  assert (isList list) (strCat (cons 'strCat list should be type cons or nil but it is type ' (cons (getType list) (cons ': ' (cons list))))) list
strAdd str1 str2 = _strAdd (assertType 'strAdd str1' '*string' str1) (assertType 'strAdd str2' '*string' str2)
strMatch str pat = _strMatch
  assertType 'strMatch str' '*string' str
  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strMatch pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat
strToList str = _strToList (assertType 'strToList str' '*string' str)
strFromList list = _strFromList
  assert (isList list) (strCat (cons 'strFromList list should be type cons or nil but it is type ' (cons (getType list) (cons ': ' (cons list))))) list
regexp str = _regexp (assertType 'regexp str' '*string' str)
regexpFlags str flags = _regexpFlags
  assertType 'regexp str' '*string' str
  assertType 'regexp flags' '*string' flags
jsonParse str failure success = _jsonParse
  assertType 'jsonParse str' '*string' str
  failure
  success

############
# UTILS
############

show x = _show x

############
# FUNCTIONS
############

id x = x
compose f g = \x . f (g x)

# make a new function that takes two args in opposite order than the original function
# eq. flip cons nil 1 gives cons: [1]
flip func = \x y . func y x

# The Y combinator, for reference
#
# Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
# rec = \f . f (Y f)

##############
# CONS LISTS
##############

cons a b = \f . f a b
isCons c = hasType c cons
isList l = or (hasType l cons) (hasType l nil)
assertType msg type value = assert (hasType value type) (strCat (cons msg (cons ' should be type ' (cons (getDataType type) (cons ', but its type is ' (cons (getType value) (cons ': ' (cons (show value) nil)))))))) value
# nil is the same as false, but it's useful separate as a marker
nil = \a b . b
isNil n = hasType n nil
head l = l \h t . h
tail l = l \h t . t
last l = isNil (tail l)
  head l
  last (tail l)
removeLast l = isNil (tail l)
  nil
  cons (head l) (removeLast (tail l))
length list = isCons list
  + 1 (length (tail list))
  assert (== nil list) (strCat (cons "length argument is not a proper list: " (cons list nil))) 0
append a b = isNil a
  b
  cons (head a) (append (tail a) b)
flatten list = isCons list
  subflatten list nil
  list
subflatten list result = isNil list
  result
  isCons list
    subflatten (head list) (subflatten (tail list) result)
    cons list result
reverse l = rev l nil
rev l result = isNil l
  result
  rev (tail l) (cons (head l) result)
filter func list = isNil list
  nil
  func (head list) (cons (head list)) id (filter func (tail list))
find predicate list = isNil list
  none
  predicate (head list) (some (head list)) (find predicate (tail list))
contains list item = find (\el . eq el item) list (\x . true) false

# make a new list by applying func (which takes exactly 1 arg) to each element of list
# eg. map (+ 1) [4 27 54] gives cons: [5 28 55]
map func l = isNil l
  nil
  cons (func (head l)) (map func (tail l))

# map, but preserve the old list where possible, so that == works on it
mapSave func l = isNil l
  nil
  \\
    newH = func (head l)
    newT = mapSave func (tail l)
    .
    and (eq newH (head l)) (eq newT (tail l))
      l
      cons newH newT

# foldl (\prev el . ...) list
# foldr (\el prev . ...) list
# call func on list items and previous result of fold
# foldl uses the head of the list for the previous results
# foldr uses the tail of the list for the previous results
# foldr can work on infinite lists, but foldl cannot
foldl func initialValue l = l (\h t D . foldl func (func initialValue h) t) initialValue
foldl1 func l = l \h t . foldl func h t
foldr func initialValue list = list
  \h t D . func h (foldr func initialValue t)
  initialValue
foldr1 func list = list \h t . isNil t
  h
  func h (foldr1 func t)

intersperse list element = list (\h t D .
  isNil t
    list
    cons h (cons element (intersperse t element))) nil

join list el = strCat (intersperse list el)
findIndex func list = idx list func 0
idx list func pos = list
  \h t D . func h
    pos
    idx t func (+ 1 pos)
  -1
index list el = find (\item . == el item) list

increasing x = cons x (increasing (+ x 1))
wholes = increasing 0
naturals = tail wholes

zip a b = isNil a
  nil
  isNil b
    nil
    cons (cons (head a) (head b)) (zip (tail a) (tail b))

############
# ASSOC LISTS
############
assertAlist msg value result = assert (isAlist value) (strCat (cons msg (cons ' should be a association list, but it is not; its type is ' (cons (getType value) (cons ': ' (cons (show value) nil)))))) result
acons k v alist = assertAlist "acons alist" alist (\@ type cons . \f . \@ assoc true . f (cons k v) alist)
assoc k alist  = find (\el . eq k (head el)) alist (\cell . cell \head tail . some tail) none
rassoc v alist = find (\el . eq v (tail el)) alist (\cell . cell \head tail . some head) none
isAlist obj = or (isNil obj) (hasProperty obj 'assoc')
aconsPair keyValue list = \@ type cons . \f . \@ assoc true . f keyValue list
appendAlist a b = isNil a
  b
  aconsPair (head a) (appendAlist (tail a) b)
keys list = map (\l . head l) list

getProperty func prop = getProperties func
  \props . assoc prop props
  none

hasProperty func prop = getProperty func prop
  \_ . true
  false

############
# SORTING
############
quicksort less list = (qs less list) nil
# qs is written using a difference list so it can append in linear time
# sortedFunc must return whether the two args are in sorted order
# \rest . (qs ... makes a difference list.  id is the empty difference list.
qs sortedFunc list = list
  \h t D . \\
    greater = filter (sortedFunc h) t
    lesser = filter (compose not (sortedFunc h)) t
    .
    \rest . (qs sortedFunc lesser) (cons h ((qs sortedFunc greater) rest))
  id
insertSorted sortFunc item list = list
  \h t D . sortFunc item h (cons item list) (cons h (insertSorted sortFunc item t))
  cons item nil

############
# TOKENS
############

token txt pos = \f . f txt pos
tokenString tok = tok \t p . t
tokenFilepos tok = tok \t p . p
#tokenPos tok = tok \t p . p
# TODO -- remove the non-filepos condition
tokenPos tok = tok \t p . isFilepos p
  fileposOffset p
  p
isToken t = hasType t token

emptyLineStarts = cons 'EMPTYFILE.lsr' (cons 1 nil)

filepos file line offset = \f . f file line offset
fileposFile p = p \file line offset . file
fileposLine p = p \file line offset . line
fileposOffset p = p \file line offset . offset
isFilepos p = hasType p filepos
# TODO -- remove the non-filepos condition
addFilepos pos change = isFilepos pos pos emptyFilePos
  \file line offset . filepos file line (+ offset change)
emptyFilePos = filepos 'NOTHING.lsr' 0 0
isEmptyPos pos = and (isFilepos pos) (and (eq 0 (fileposLine pos)) (eq 0 (fileposOffset pos)))
emptyFor thing = filepos (fileposFile (position thing)) 0 0
startFilePos = emptyFilePos
filePosFor lineStarts offset = countFilePos (head (tail lineStarts)) 0 (tail (tail lineStarts)) offset
  \line offset . filepos (head lineStarts) line offset
countFilePos line lineOffset starts offset = or (isNil starts) (> (head starts) offset)
  \f . f line (- offset lineOffset)
  countFilePos (+ line 1) (head starts) (tail starts) offset
fileposList pos = pos \file line offset . cons line (cons offset nil)

parens start end content = \f . f start end content
parensStart p = p \s e c . s
parensEnd p = p \s e c . e
parensContent p = p \s e c . c
isParens p = hasType p parens
makeParens start end content =
  and (isCons content) (isNil (tail content))
    makeParens start end (head content)
    or (isToken content) (isParens content)
      content
      parens start end content
parensFromToks left right content = \\
  start = tokenFilepos left
  end = addFilepos (tokenFilepos right) (strLen (tokenString right))
  .
  parens start end content
stripParens p = isParens p (parensContent p) p

parseErr msg1 msg2 = \f . f (strCat (cons msg1 (cons msg2 nil)))
parseErrMsg err = err \m . m
isParseErr thing = hasType thing parseErr

emptyToken = regexp '^\\r?\\n[ \\i]*(#|$)'

makeTokens lineStarts strings start = strings (\h t D . makeMoreTokens lineStarts h t start) nil
makeMoreTokens lineStarts h t start = \\
  next = makeTokens lineStarts t (+ start (strLen h))
  .
  and (strMatches h emptyToken) (or (isNil t) (or (strStartsWith (head t) '\n') (strStartsWith (head t) '\r\n')))
    makeTokens lineStarts t (+ start (strLen h))
    or (strStartsWith h ' ') (strStartsWith h '#')
      next
      and (or (strStartsWith h '\n') (strStartsWith h '\r\n')) (strStartsWith (head t) '#')
        makeTokens lineStarts (tail t) (+ start (+ (strLen h) (strLen (head t))))
        #cons (token h start) next
        cons (makeTokenAt lineStarts h start) next
#makeTokenAt lineStarts txt offset = showToken (token txt (filePosFor lineStarts offset))
makeTokenAt lineStarts txt offset = token txt (filePosFor lineStarts offset)

showToken tok = log (strCat (cons 'token: ' (cons (tokenString tok) (cons ', ' (cons (showPos (tokenPos tok)) nil))))) tok

showPos pos = isFilepos pos
  strCat (cons 'position: ' (cons (fileposFile pos) (cons ', ' (cons (fileposLine pos) (cons '.' (cons (fileposOffset pos) nil))))))
  pos

splitTokens str pat = filter (\s . not (eq s '')) (basicSplitTokens str pat true)

numberPat = regexp '-?([0-9]+(\\.[0-9]+)?|\\.[0-9]+)'

matchOffset str match = isNil match
  strLen str
  head (tail (tail match))

basicSplitTokens str pat prevIsDel = == str ''
  nil
  \\
    num = strMatch str numberPat
    del = strMatch str pat
    numOffset = matchOffset str num
    delOffset = matchOffset str del
    select = and (== numOffset 0) prevIsDel
      \del num first . num
      == delOffset 0
        \del num first . del
        \del num first . first
    first = select (head del) (head num) (strSubstring str 0 delOffset)
    .
    cons
      first
      basicSplitTokens
        strSubstring str (strLen first) 0
        pat
        select true false false

tokens str pat = countedTokens emptyLineStarts str pat

countedTokens lineStarts str pat = makeTokens lineStarts (splitTokens str pat) 0

#############
## Parsing
#############

isString s = == (getType s) '*string'
isNumber s = == (getType s) '*number'
isTokenString tok str = or
  and (isToken tok) (eq (tokenString tok) str)
  and (isString tok) (eq tok str)
isTokenStart tok str = or
  and (isToken tok) (strStartsWith (tokenString tok) str)
  and (isString tok) (strStartsWith tok str)
strTokenString tok = withToken tok nil \str pos . str
withToken tok nonTokCase tokCase = isToken tok
  tokCase (tokenString tok) (tokenPos tok)
  isString tok
    tokCase tok emptyFilePos
    nonTokCase

## withCons is like a safe version of a cons
withCons l nilCase cont = isCons l (l (\h t D . cont h t) nilCase) nilCase

ifNotErr thing cont = hasType thing parseErr thing (cont thing)

parseToks toks groups =
  isNil toks nil
    ifNotErr (parseTok toks groups) \list . list \h t .
      ifNotErr (parseToks t groups) \res .
        cons h
          and (isCons res) (isBlockStart (head res))
            cons res nil
            res

parseTok toks groups = withCons toks nil \h t .
  withToken h toks \txt pos .
    assoc txt groups
      \close . parseGroup h t nil close groups
      (or (isTokenStart h '\n') (isTokenStart h '\r\n')) (parseIndent h t nil groups)
        toks

parseGroup left toks gr close groups = withCons toks (parseErr 'Unterminated group starting ' (loc left))
  \h t . isTokenString h close
    eq close ')'
      cons (parensFromToks left h (reverse gr)) t
      cons (cons left (cons (reverse gr) (cons h nil))) t
    withToken h
      ifNotErr (parseTok toks groups) \list . list \restH restT .
        parseGroup left restT (cons restH gr) close groups
      \txt pos .
        rassoc txt groups
          \open . parseErr (strCat (cons 'Mismatched group: ' (cons (tokenString left) (cons txt (cons ' ' nil))))) (loc left)
          ifNotErr (parseTok toks groups) \list . list \restH restT . parseGroup left restT (cons restH gr) close groups

parseIndent indent toks gr groups =
  withCons toks (cons (makeParens (tokenFilepos indent) (lexEnd (head gr)) (reverse gr)) nil)
    \h t . or (withToken h false (\txt pos . rassoc txt groups (\open . true) false))
      and (or (isTokenStart h '\n') (isTokenStart h '\r\n')) (<= (strLen (tokenString h)) (strLen (tokenString indent)))
      cons (makeParens (tokenFilepos indent) (tokenFilepos h) (reverse gr)) toks
      ifNotErr (parseTok toks groups) \list . list \restH restT . parseIndent indent restT (cons restH gr) groups

#################
## Creating ASTs
#################

# lit and ref are the easiest
# maybe we should encode a range as [startLine startCol endLine endCol] and just add range args to things
# lits and refs can have an extra range arg
# actually, I think lambda and let only need one range, just for their vars/names because their bodies will have ranges
# applies probably don't need a range at this point, since their func and arg have ranges
# anno probably don't need ranges, since they don't directly gen code
nilRange = cons 1 (cons 0 nil)
lit value range = \f . f value range
ref name range = \f . f name range
lambda name body range = \f . f name body range
apply func arg = \f . f func arg
let name value body range = \f . f name value body range
anno name data body = \f . f name data body

withParens p err cont = isParens p (p cont) err
setParens p func = isParens p
  p \start end content . parens start end (func content)
  func p

withStripped list cont = withParens list (cont list) \start end content . withStripped content cont

position thing = isToken thing (tokenFilepos thing)
  isParens thing (parensStart thing)
    isCons thing
      \\
        pos = position (head thing)
        .
        isEmptyPos pos (position (tail thing)) pos
      isFilepos thing thing
        emptyFilePos

lexEnd thing = isToken thing (addFilepos (tokenFilepos thing) (strLen (tokenString thing)))
  isParens thing (parensEnd thing)
    isCons thing (lexEnd (last thing))
      emptyFilePos

loc thing = \\
  p = position thing
  l = isEmptyPos p 'an unknown location' (showPos p)
  .
  strCat (cons 'at ' (cons l nil))

scrub str = strFromList (scrubList (strToList str))

scrubList list = list
  \h t D . \\
    next = scrubList t
    .
    eq h '\\' (cons h (cons (head t) (scrubList (tail t))))
      eq h '\"' (cons '\\' (cons '\"' next))
        cons h next
  nil

createAst lineStarts inList names = withStripped inList \list .
  isToken list (createLitOrRef list names)
    list
      \h t D .
        isTokenString h '\\\\' (createLet h t names)
          isTokenString h '\\@' (createAnno h t names)
            isTokenString h '\\' (createLambda h t names)
              createApply list names
      nil

strMatches str pat = isCons (strMatch str pat)

digit = regexp '^[0-9]+$'

backslashCodes = 'bfnrt'

backslashValues = '\b\f\n\r\t'

convertStringEscape char codes values =
  eq codes ''
    char
    eq char (strAt codes 0)
      strAt values 0
      convertStringEscape char (strSubstring codes 1 0) (strSubstring values 1 0)

convertStringEscapes orig str cont =
  eq str ''
    cont str
    eq (strAt str 0) '\\'
      eq (strLen str) 1 (parseErr "Error, backslash without character in string: " orig)
        convertStringEscapes orig (strSubstring str 2 0) \rest . cont
          strAdd
            convertStringEscape (strAt str 1) backslashCodes backslashValues
            rest
      convertStringEscapes orig (strSubstring str 1 0) \rest . cont
        strAdd
          strAt str 0
          rest

parseString str cont =
  neq (strAt str 0) (strAt str -1) (parseErr "Badly terminated string: " str)
    convertStringEscapes str (strSubstring str 1 -1) cont

createLitOrRef token names = \\
  tok = tokenString token
  tokRange = (fileposList (position token))
  #tokRange = nilRange
  .
  contains names tok
    ref tok tokRange
    or (strStartsWith tok '\"') (strStartsWith tok "'")
      parseString tok \str . lit str tokRange
      strStartsWith tok '.'
        jsonParse (strCat (cons '0' (cons tok nil))) (\err . ref tok tokRange) (\item . lit item tokRange)
        or (and (>= (strAt tok 0) '0') (<= (strAt tok 0) '9')) (strStartsWith tok '-')
          jsonParse tok (\err . ref tok tokRange) (\item . lit item tokRange)
          ref tok tokRange

createLambda start list names = \\
  err = parseErr "Lambda needs a variable name, a dot, and a body " (loc start)
  .
  withCons list err \name rest .
    withToken name err \n p .
      withCons rest err \dot body .
        # are these partial applications too hard to read?
        isTokenString dot '.'
          ifNotErr (createAst nil body (cons n names)) \bodyAst . lambda n bodyAst nilRange
          ifNotErr (createLambda start rest (cons n names)) \bodyAst . lambda n bodyAst nilRange

createAnno start list names =
  withCons list (parseErr "No annotation name or data in annotation " (loc start)) \name rest .
    withCons rest (parseErr "No data for annotation " (loc start)) \data rest . \\
      finish data body = ifNotErr (createAst nil body names) \bodyAst .
        cleanTokens start name \name .
          cleanTokens start data \data .
            anno name data bodyAst
      .
      isTokenString data '.'
        finish nil rest
        withStripped data \data .
          withCons rest (parseErr "No body for annotation " (loc start)) \dot body .
            isTokenString dot '.'
              finish data body
              parseErr "Annotation expects dot after name and data " (loc start)

bodyStructPat = regexp '\\|\\\\|\\@'

createApply inList names = withStripped inList \list .
  withCons list (parseErr "Funcion apply expecting a non-empty list " (loc inList)) \h t .
    ifNotErr (createAst nil h names) \func . chainApply func t names

blockStarts = cons '\\' (cons '\\\\' (cons '\\@' nil))

chainApply func list names = withCons list func \argItem rest .
  and (isToken argItem) (contains blockStarts (tokenString argItem))
    ifNotErr (createAst nil list names) \arg . apply func arg
    ifNotErr (createAst nil argItem names) \arg . chainApply (apply func arg) rest names

cleanTokens start toks cont = isToken toks
  cont (tokenString toks)
  withCons toks (cont toks) \head tail .
    cleanTokens start head \head .
      cleanTokens start tail \tail .
        cont (cons head tail)

createLet start list names = withCons list
  parseErr "No variable or body for let " (loc start)
  \binding body . eq body nil (createAst nil binding name)
    ifNotErr (getLetNames start list names) \newNames .
      createSublets start binding body newNames

getLetNames start list names = \\
  err = parseErr "Let expected binding " (loc start)
  .
  withCons list names \binding body .
    isTokenString binding '.' names
      withParens binding err \start end def .
        withCons def err \name rest .
          withToken name err \str pos .
            getLetNames start body (cons str names)

createSublets start binding body names =
  isTokenString binding '.' (createAst nil body names)
    withCons body (parseErr "Let expected a body " (loc start)) \bodyH bodyT .
      ifNotErr (getNameAndDef (parensStart binding) (parensContent binding) names) \res . res \name def .
        ifNotErr (createSublets start bodyH bodyT names) \bodyAst .
          let (tokenString name) def bodyAst nilRange

getNameAndDef pos binding names =
  withCons (tail binding) (parseErr "Let expected binding at " pos) \snd sndT .
    isTokenString snd '=' (ifNotErr (createAst nil sndT names) \def . cons (head binding) def)
      ifNotErr (getLetLambda pos (tail binding) nil names) \lamb . cons (head binding) lamb

getLetLambda pos def args names =
  withCons def (parseErr "Let expected binding at " pos) \arg rest .
    not (isToken arg) (parseErr "Let expected binding at " pos)
      isTokenString arg '='
        createAst nil (cons (token '\\' pos) (append (reverse args) (cons (token '.' (position arg)) rest))) names
        getLetLambda pos rest (cons arg args) names

#################
## Compiling
#################

scanLineG str pat groups onDef onExpr = countedScanLineG emptyLineStarts str pat groups onDef onExpr

countedScanLineG lineStarts str pat groups onDef onExpr = \\
  toks = countedTokens lineStarts str pat
  groupToks = foldr (\el value . el \h t . cons h (cons t value)) (cons '=' blockStarts) groups
  .
  # check if it's a definition
  find (\tok . or (contains groupToks (tokenString tok)) (isCons (strMatch (tokenString tok) '^\r?\n'))) toks (\item . isTokenString item '=') false
    toks \name rest . \\
      parseIt func = \\
        parsed = parseToks (checkSetDataType func rest name) groups
        .
        onDef (ifNotErr parsed \list . createDef list name (arity rest 0) str)
      .
      isTokenString (head rest) '='
        isTokenString (head (tail rest)) '\\'
          parseIt (setTypeAnno (tail rest) (tokenString name))
          parseIt (tail rest)
        ifNotErr (transformDef name rest) \def .
          parseIt (cons (token '\\' (- (position (head rest)) 1)) def)
    ifNotErr (parseToks toks groups) \list . onExpr list

parseLineG str pat names groups onDef onExpr = \\
  astCallback cb = \list . ifNotErr (createAst nil list names) \ast . cb ast
  .
  scanLineG str pat groups (astCallback onDef) (astCallback onExpr)

transformDef name toks = withCons toks (parseErr "Bad definition, expecting tokens" (loc name)) \h t .
  isTokenString h '='
    isTokenString (head t) '\\'
      cons (token '.' (position h)) (setTypeAnno t (tokenString name))
      cons (token '.' (position h)) t
    ifNotErr (transformDef name t) \list . cons h list

setTypeAnno toks name = \\
  tok = \str . token str (position toks)
  .
  cons (tok '\\@') (cons (tok 'type') (cons (tok name) (cons (tok '.') toks)))

setDataTypeAnno toks name = \\
  tok = \str . token str (position toks)
  .
  cons (tok '\\@') (cons (tok 'dataType') (cons (tok (tokenString name)) (cons (tok '.') toks)))

createDef def name arity src = \\
  #tok str = token str (position def)
  tok str = token str (position name)
  .
  jsonStringify (tokenString name) (\err . parseErr (strCat (cons "Bad function name " (cons (loc name) nil))) err) \nameStr .
    jsonStringify src (\err . parseErr (strCat (cons "Bad source " (cons (loc name) nil))) err) \srcStr .
      cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil))))
      #cons (tok '\\@') (cons (cons (tok 'definition') (cons (tok name) nil)) (cons (tok '.') (cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil)))))))

checkSetDataType toks curToks name = withCons curToks toks \h t .
  isTokenString h '='
    isTokenString (head t) '\\'
      setDataTypeAnno toks name
      toks
    checkSetDataType toks t name

arity toks n = isTokenString (head toks) '=' n (arity (tail toks) (+ n 1))

tokListStr toks = jsonStringify (join (map (\t . tokenString t) toks) ' ')

linePat = regexp '\\r?\\n(?=[^ ]|$)'

emptyLinePat = regexp '(^[ \\i]*\\#.*|^[ \\i]*$|^\\r?\\n[ \\i]*$)'

lineScrub = regexpFlags '\\r\\n' 'g'

####
# line counting
####
# a lineStarts list is [filename lineNumber lineStartOffset...]
# so ['file1.lsr' 32 17 83] means
#  this string starts at line 32 in file1.lsr
#  line 33 starts at position 17 in the string
#  line 34 starts at position 83 in the string

linesForFile text = map tail (countedLinesForFile "NOTHING.lsr" text)

countedLinesForFile name text = filter
  \line . isNil (strMatch (tail line) emptyLinePat)
  countedLines name 1 text

# 1-based offset for lines
countedLines filename lineOffset str = \\
  m = strMatch str linePat
  idx = head (tail (tail m))
  chunk = strSubstring str 0 idx
  next = + idx (strLen (head m))
  chunkLines = findLines 0 chunk
  .
  eq str ''
    nil
    isNil m
      cons (cons (cons filename (cons lineOffset (tail (findLines 0 str)))) str) nil
      cons (cons (cons filename (cons lineOffset (tail chunkLines))) chunk)
        countedLines filename (+ lineOffset (length chunkLines)) (strSubstring str next 0)

defPat = regexp '^[^ =]+.* =( |$)'

#unanchoredDefPat = regexp '(^|\\n)[^ =]+.* =([ \\n]|$)'

unanchoredDefPat = regexp '^((?:\\s*\\n|#[^\\n]*\\n)*)([^=\\n]*)(=\\([^=]+=|=)?'

namesForLines lines = foldl
  \result line . \\
    m = strMatch line defPat
    .
    isNil m result (cons (head (tail m)) result)
  nil
  lines

#################
## Macro system
#################

# what about alpha substitution to make the result hygenic?
# make some let-style macros that use gensyms?

runParseFilters filters line = filters
  \h t D . bind (h line) \filtered . runParseFilters t filtered
  line

isBlockStart tok = and
  or (isToken tok) (isString tok)
  contains blockStarts (strTokenString tok)

# macs is an assoc-list (list of (name . definition))
# expr is the tail of the macro expression
# macros can be IO monads
macroSub macs expr = postProcessMacro (emptyFor expr) (emptyFor expr) (baseMacroSub macs expr)

consifyMacroValue value = isCons value value (cons value nil)

baseMacroSub macs expr = isToken expr
  expr
  isParens expr
    expr \start end content . \\
      result = baseMacroSub macs content
      .
      isToken result result (parens start end result)
    withCons expr expr \h t .
      isBlockStart h
        cons h
          isTokenString h '\\\\'
            macroSubLet macs t
            macroSubBody '.' macs t
        withToken h
          \\
            subH = baseMacroSub macs h
            .
            withToken subH
              cons subH (map (baseMacroSub macs) t)
              \tok pos . baseMacroSub macs (cons subH t)
          \tok pos . assoc tok macs
            \def . baseMacroSub macs (def t)
            cons h (map (baseMacroSub macs) t)

macroSubLet macs list = list
  \h t D . isTokenString h '.'
    cons h (baseMacroSub macs t)
    cons (setParens h \content . macroSubBody '=' macs content) (macroSubLet macs t)
  # Don't bother with parse errors at this point -- ast generator will detect them
  nil

macroSubBody char macs list = list
  \h t D . cons h
    isTokenString h char baseMacroSub (macroSubBody char)
      macs
      t
  nil

postProcessMacro before after expr = isString expr
  token expr (isEmptyPos after before after)
  isParens expr
    expr \start end contents . parens start end (postProcessMacro start end contents)
    isCons expr
      expr \h t .
        isToken h
          cons h (postProcessMacro (addFilepos (addFilepos (tokenFilepos h) (strLen (tokenString h))) 1) (emptyFor h) t)
          \\
            posStart = position h
            posEnd = position t
            t2 = postProcessMacro (emptyFor posStart) after t
            h2 = postProcessMacro before (emptyFor posStart) h
            .
            isEmptyPos posStart
              cons (postProcessMacro before (position t2) h) t2
              cons h2 (postProcessMacro (addFilepos (lexEnd h2) 1) after t)
      isNumber expr
        token (strString expr) (isEmptyPos after before after)
        expr

defMacro name def = bind (getValue 'macroDefs') \macs . setValue 'macroDefs' (acons name def macs)

#################
# Token Patterns
#################

delimiterListPrefix = "\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\r?\\n *|#.*| +"

regexpEscapePat = regexpFlags '[\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]' 'g'

addToken del = bind (getValue 'tokenList')
  \dels . contains dels del
    false
    \\
      newDels = insertSorted (\a b . > (strLen a) (strLen b)) del dels
      .
      bind (setValue 'tokenList' newDels)
        \_ . computeTokenPat newDels

computeTokenPat dels = \\
  delPats = map (\item . strReplace item regexpEscapePat "\\$&") dels
  newPat = strCat (cons '(' (cons (join (cons delimiterListPrefix delPats) '|') (cons ')' nil)))
  .
  setValue 'tokenPat' newPat

addTokenGroup open close = bind (addToken open)
  \_ . bind (addToken close)
    \_ . bind (getValue 'tokenGroups')
      \gr . setValue 'tokenGroups' (acons open close gr)

#################
## INTERFACE
#################

#################
## TESTING
#################

parenGroups = acons '(' ')' nil

parse str pat = ifNotErr (parseIndent (token '\n' startFilePos) (tokens str pat) nil parenGroups) \list . list \h t . stripParens h

parseG str pat groups = ifNotErr (parseIndent (token '\n' startFilePos) (tokens str pat) nil groups) \list . list \h t . stripParens h

parseToAst str pat = createAst nil (parse str pat) nil

parseM str =
  bind (getValue 'tokenPat')
    \tokPat . bind (getValue 'tokenGroups')
      \groups . parseG str tokPat groups

scanLine str pat onDef onExpr = scanLineG str pat parenGroups onDef onExpr

parseLine str pat names onDef onExpr = parseLineG str pat names parenGroups onDef onExpr

parseLineM str = bind (getValue 'tokenPat')
  \tokPat . bind (getValue 'tokenGroups')
    \groups . parseLineG str tokPat nil groups id id

macroSubM expr =
  bind (getValue 'macroDefs')
    \macs . macroSub macs expr

macroParse str =
  bind (parseM str)
    \ex . macroSubM ex

tokensM str =
  bind (getValue 'tokenPat')
    \delimiterPat . tokens str delimiterPat

parseLines lines result = lines
  \h t D . bind (parseLineM h)
    \ast . parseLines t (cons ast result)
  reverse result

parseFile text = parseLines (linesForFile text) nil

simpleScanLine line = bind (getValue 'tokenPat')
  \tokenPat . bind (getValue 'tokenGroups')
    \groups . scanLineG line tokenPat groups id id

scanLineM line = countedScanLineM emptyLineStarts line

countedScanLineM lineStarts line = bind (getValue 'tokenPat')
  \tokenPat . bind (getValue 'tokenGroups')
    \groups . bind (getValue 'parseFilters')
      \filters . bind (getValue 'macroDefs')
        \macros . bind (runParseFilters filters (countedScanLineG lineStarts line tokenPat groups id id))
          \scanned . macroSub macros scanned

newline = regexp '\\r?\\n'

# Find line ends in a chunk (overhanging line with indented lines under it)
findLines offset line = \\
  m = strMatch line newline
  idx = + 1 (head (tail (tail m)))
  .
  eq m nil
    cons offset nil
    cons offset (findLines (+ offset idx) (strSubstring line idx 0))

newParseLine offset names line = bind (scanLineM line)
  \scanned . ifNotErr (createAst (cons "NEWPARSE.lsr" (findLines offset line)) scanned names) \ast . ast

countedParseLine names countedLine = bind (scanLineM (tail countedLine))
  \scanned . ifNotErr (createAst (head countedLine) scanned names) \ast . ast

runLine offset names line = bind (newParseLine offset names line)
  \ast . bind (runAst ast)
    \result . cons
      ast
      isParseErr result
        left (parseErrMsg result)
        right result

countedRunLine file names countedLine = \\
  parsed = countedParseLine names countedLine
  .
  bind parsed
  \ast . \\
    wrapped = astFileWrap file ast
    .
    bind (runAst wrapped)
      \result . cons
        wrapped
        isParseErr result
          left (parseErrMsg result)
          right result

#astFileWrap parsed ast = d "AST POSITION: " (showPos (position parsed)) ast
astFileWrap file ast = anno 'filename' file ast

runLines names lines = lines
  \h t D . bind (runLine 0 names h)
    \line . bind (runLines names t)
      \rest . cons line rest
  nil

countedRunLines file names countedLines = countedLines
  \h t D . bind (countedRunLine file names h)
    \line . bind (countedRunLines file names t)
      \rest . cons line rest
  nil

runFile text = runNamedFile "RUNFILE.lsr" text

runNamedFile name text = \\
  counted = countedLinesForFile name text
  lines = map tail counted
  names = namesForLines lines
  .
  d 'Running file: ' name countedRunLines name names counted

baseLoad file = bind (readFile file)
  \result . result
    \err . err
    \contents . bind (getValue 'activeTokenPacks')
      \activePacks . bind resetStdTokenPacks
        \_ . bind (runNamedFile file contents)
          \result . isNil activePacks
            bind resetStdTokenPacks
              \_ . result
            bind (resetTokenPacks activePacks)
                \_ . result

load file = bind (baseLoad file)
  \result . \\
    errs = foldr (\line results . tail line (\er . cons er results) (\x . results)) nil result
    .
    isNil errs
      right true
      left errs

require file = bind (getValue 'requiredFiles')
  \files . contains files file
    right false
    bind (setValue 'requiredFiles' (cons file files))
      \_. bind (load file)
        \result . result
          \x . left x
          \_ . right true

################
# Token Packs
################

#newGen

# pack is (tokens groups filters)
defTokenPack name pack = bind (getValue 'tokenPacks')
  \packs . setValue 'tokenPacks' (acons name pack packs)

useTokenPack name = bind (getValue 'tokenPacks')
  \packs . bind (getValue 'tokenGroups')
    \groups . bind (getValue 'tokenList')
      \tokens . bind (getValue 'activeTokenPacks')
        \activePacks . bind (getValue 'parseFilters')
          \filters . assoc name packs
            \pack . \\
              groupToks = foldl (\value el . el \h t . cons h (cons t value)) nil (head (tail pack))
              newToks = quicksort (\a b . > (strLen a) (strLen b)) (append (head pack) (append groupToks tokens))
              .
              bind (setValue 'tokenList' newToks)
                \_ . bind (setValue 'tokenGroups' (appendAlist (head (tail pack)) groups))
                  \_ . bind (setValue 'parseFilters' (append filters (head (tail (tail pack)))))
                    \_ . bind (computeTokenPat newToks)
                      \_ . setValue 'activeTokenPacks' (cons name activePacks)
            nil

resetTokenPacks packs = bind (setValue 'tokenGroups' nil)
  \_ . bind (setValue 'tokenList' nil)
    \_ . bind (setValue 'activeTokenPacks' nil)
      \_ . bind (setValue 'parseFilters' nil)
        \_ . foldr1
          \packCmd result . bind packCmd \_ . result
          map useTokenPack packs

resetStdTokenPacks = bind (getValue 'stdTokenPacks')
  \stds . bind (resetTokenPacks stds)
    \_ . setValue 'activeTokenPacks' nil

addStdTokenPacks morePacks = bind (getValue 'stdTokenPacks')
  \stds . setValue 'stdTokenPacks' (append stds morePacks)

addParseFilter filt = bind (getValue 'parseFilters')
  \filters . setValue 'parseFilters' (append filters (cons filt nil))

############
# DIAG
############

#newGen

d label value expr = log (strCat (cons label (cons value nil))) expr
dd label arg = d label arg arg

############
## SETTINGS
############

setValue 'macroDefs' nil
setValue 'requiredFiles' nil
setValue 'tokenPacks' nil
setValue 'activeTokenPacks' nil
setValue 'stdTokenPacks' (cons 'std' nil)

defTokenPack 'std' (cons (cons '.' (cons '\\' (cons '\\\\' (cons '\\@' nil)))) (cons (acons '(' ')' nil) (cons nil nil)))

resetStdTokenPacks

newGen

#################
# Utilities
#################

addTokenGroup '[' ']'
addToken '|'

listifyOp op list = list
  \h t D . isTokenString h '|'
    cons t nil
    cons (cons op (cons h (listifyOp op t))) nil
  cons 'nil' nil

listify list = listifyOp 'cons' list

defMacro '[' \list . list \h t . listify h

listFilter code = bind (getValue 'listMacros')
  \listMacros . filterApplies code \list . list \h t .
    and (isToken h) (contains listMacros (tokenString h))
      listFilterTail list
      list

listFilterTail list = list
  \h t D . isTokenString h '|'
    > (length t) 2
      cons h (cons (removeLast t) (cons (last t) nil))
      list
    cons h (listFilterTail t)
  nil

filterApplies code func = isParens code
  code \start end contents . parens start end (filterApplies contents func)
  isCons code
    \\
      filtered = filterApplyElements code func
      .
      and (isCons filtered) (isBlockStart (head filtered))
        filtered
        func filtered
    code

filterApplyElements code func = code
  \h t D . isBlockStart h
    cons h (filterBlock h t func)
    cons (filterApplies h func)
      and (isCons t) (isBlockStart (head t))
        cons (filterApplyElements t func) nil
        filterApplyElements t func
  nil

filterBlock type code func = isTokenString type '\\'
  filterLambda code func
  filterLet code func

filterLet code func = code \h t . isTokenString h '.'
  cons h (filterApplies t func)
  cons (filterLetBinding h func)
    filterLet t func

filterLetBinding code func = isParens code
  setParens code \contents . filterLetBinding contents func
  isCons code
    code \h t . cons h
      isTokenString h '='
        filterApplies t func
        filterLetBinding t func
    code

filterLambda code func = code \h t . cons h
  isTokenString h '.'
    filterApplies t func
    filterLambda t func

setValue 'listMacros' ['[' '{' 'hamt{']

addParseFilter listFilter

addTokenGroup '{' '}'

defMacro '{' \list . list \h t . listifyOp 'aconsPair' h

addTokenGroup 'hamt{' '}'

defMacro 'hamt{' \list . list \h t . hamtify h

hamtWithPair pair t = hamtWith (head pair) (tail pair) t

hamtify list = list
  \h t D . isTokenString h '|'
    cons t nil
    and (isCons h) (or (isTokenString (head h) 'cons') (isTokenString (head h) ':'))
      [['hamtWith' (head (tail h)) (head (tail (tail h))) | hamtify t]]
      [['hamtWithPair' h | hamtify t]]
  ['hamt']

defTokenPack 'list' [
  ['|' '='] #adding = here so so we don't need spaces around = in definitions
  {['{' | '}'] ['hamt{' | '}'] ['[' | ']'] ['or[' | ']'] ['and[' | ']'] ['concat[' | ']'] ['concatFlat[' | ']']}
  [listFilter]]

### Yay!  From here down, we can use list constructors!

addTokenGroup 'or[' ']'

addTokenGroup 'and[' ']'

addTokenGroup 'concat[' ']'

addTokenGroup 'concatFlat[' ']'

listMacroFoldOp op emptyCase list = list \h t . foldr
    \case result . [op case result]
    emptyCase
    h

defMacro 'or[' \list . listMacroFoldOp 'or' 'false' list

defMacro 'and[' \list . listMacroFoldOp 'and' 'true' list

defMacro 'concat[' \list . ['strCat' [(listify (head list))]]

defMacro 'concatFlat[' \list . ['strCat' ['flatten' [(listify (head list))]]]

bind (getValue 'listMacros')
  \lm . ['concat[' | lm]

infix code = bind (getValue 'infixPrecedence')
  \prec . bind (getValue 'infixRightAssociative')
    \right . bind (getValue 'tokenGroups')
      \groups . filterApplies
        code
        \expr . infixRearrange prec right (map (\cell . tail cell) groups) expr

infixRearrange prec right closes list = \\
  len = length list
  head1 = head list
  tail1 = tail list
  head2 = head tail1
  tail2 = tail tail1
  head3 = head tail2
  opPrec = getPrec prec head2
  .
  < len 2
    list
    isInfix opPrec head1 head2 len
      or (== len 2) (not (isInfixArg closes head3))
        [[head2 head1] | tail2]
        infixRearrange prec right closes (absorbArgument opPrec prec right closes head1 head2 tail2 head3 (- len 2))
      [head1 | infixRearrange prec right closes tail1]

absorbArgument opPrec prec right closes head1 head2 tail2 head3 len = \\
  tail3 = tail tail2
  head4 = head tail3
  tail4 = tail tail3
  head5 = head tail4
  .
  infixShouldEatNext opPrec prec (contains right (strTokenString head2)) head3 head4 head5 closes len
    [head1 head2 | absorbArgument (getPrec prec head4) prec right closes head3 head4 tail4 head5 (- len 2)]
    [[head2 head1 head3] | tail3]

isInfixArg closes item = or[
  isParens item
  isCons item
  and[
    isToken item
    not (contains closes (tokenString item))
    not (isBlockStart item)]]

isInfix opPrec head1 head2 len = and[
  > len 1
  > opPrec -1
  isInfixArg nil head1]

getPrec prec token = \\
  str = tokenString token
  .
  isToken token
    findIndex (\level . contains level str) prec
    -1

infixShouldEatNext opPrec prec isRight curArg nextOp nextArg closes len = \\
  nextPrec = getPrec prec nextOp
  .
  and[
    > len 2
    isInfix nextPrec curArg nextOp len
    or (> opPrec nextPrec) (and (== opPrec nextPrec) isRight)
    isInfixArg closes nextArg]

defMacro ':' \list . ['cons' | list]

iprec = [['*' '/' '%'] ['+' '-'] [':'] ['<' '>' '<=' '>='] ['==' '!=']]
rightAssoc = [':']

setValue 'infixPrecedence' iprec
setValue 'infixRightAssociative' rightAssoc
defTokenPack 'infix' [(flatten iprec) [] [infix]]

useTokenPack 'infix'

################
## DO
################

defMacro 'do' \list . handleDo list false id

handleDo list inLet cont = list
  \h t D . isNil t
    cont (inLet ['.' h] [h])
    doClause (stripParens h) h nil inLet \newInLet chain .
      handleDo t newInLet \rest . cont (chain rest)
  cont nil

doClause steppingClause clause prefix inLet cont = \\
  makeBind var monad = cont false \rest . inLet (cons '.') id
    ['bind' monad ['\\' var '.' | rest]]
  .
  isCons steppingClause
    steppingClause \h t . isTokenString h '='
      inLet
        cont true \rest . [clause | rest]
        cont true \rest . ['\\\\' clause | rest]
      isTokenString h '<-'
        isNil t
          parseErr "No monad in do-clause: " clause
          prefix
            \ph pt D . isNil pt
              makeBind (isNil prefix '_' (head prefix)) t
              parseErr "More than one variable in do-clause: " clause
            makeBind '_' t
        doClause t clause [h | prefix] inLet cont
    makeBind '_' clause

defTokenPack 'do' [['<-'] [] []]

addStdTokenPacks ['list' 'infix' 'do']
resetStdTokenPacks


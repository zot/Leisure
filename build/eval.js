// Generated by CoffeeScript 2.4.1
(function() {
  // Evaulation support for Leisure
  'use strict';
  var indexOf = [].indexOf,
    slice = [].slice;

  define.amd = true;

  define(['./base', './ast', './runtime', 'acorn', 'acorn_walk', 'acorn_loose', 'lispyscript', './coffee-script', 'bluebird', './gen', 'lib/js-yaml', './docOrg', 'lodash', 'fingertree', 'browser-source-map-support', 'lib/sourcemapped-stacktrace'], function(Base, Ast, Runtime, Acorn, AcornWalk, AcornLoose, LispyScript, CS, Bluebird, Gen, Yaml, DocOrg, _, FingerTree, SourceMapSupport, SourcemappedStackTrace) {
    var CodeGenerator, ErrorCache, Html, Nil, Node, Promise, Scope, SourceMapConsumer, SourceMapGenerator, SourceNode, _true, acorn, acornLoose, acornWalk, addSourceFile, arrayify, autoLoadEnv, autoLoadProperty, basicFormat, blockSource, blockVars, blocksObserved, callFail, codeFor, codeMap, composeSourceMaps, cons, csEnv, currentGeneratedFileName, defaultEnv, defineSourceFile, dump, envTemplate, errCache, errorDiv, escapeHtml, escapeString, escaped, evalLeisure, findError, flushTraceLog, genMap, genSource, generatedFileCount, gensym, gensymCounter, getCodeItems, getLeft, getLeisurePromise, getRight, getType, getValue, handleErrors, hasCodeAttribute, html, id, indentCode, installEnv, intersperse, isError, isYamlResult, joinSourceMaps, jsBaseEval, jsCodeFor, jsEnv, jsEval, jsGatherResults, jsGatherSourceResults, jsonConvert, knownLanguages, languageEnvMaker, lazy, lc, left, leisureEnv, leisureErrorHtml, leisureExec, leisurePromise, lineColumnStrOffset, lineLocationForOffset, lispyScript, localEval, lsEnv, lz, makeHamt, makeSyncMonad, mapErrors, mapStackTrace, newConsFrom, newEvalFuncString, nextGeneratedFileName, nodesForGeneratedText, parseYaml, presentHtml, replacements, requirePromise, resolve, right, runLeisureMonad, runMonad, runMonad2, runNextResult, runWithPromiseCont, rz, setDebugType, setLounge, setValue, show, simpleEval, slashed, sn, sourceNode, sourceNodeFromCodeMap, sourceNodeTree, specials, stringFor, textEnv, unescapePresentationHtml, unescapeString, unescaped, walk, withFile, writeResults, yamlEnv;
    if (SourceMapSupport != null) {
      SourceMapSupport.install();
    }
    acorn = Acorn;
    acornWalk = AcornWalk;
    acornLoose = AcornLoose;
    lispyScript = lsrequire("lispyscript");
    ({getType, cons, unescapePresentationHtml, Nil} = Ast);
    ({Node, resolve, lazy, defaultEnv, flushTraceLog, addSourceFile} = Base);
    (typeof window !== "undefined" && window !== null ? window : global).resolve = rz = resolve;
    (typeof window !== "undefined" && window !== null ? window : global).lazy = lz = lazy;
    lc = Leisure_call;
    ({runMonad, runMonad2, newConsFrom, setValue, getValue, makeSyncMonad, makeHamt, _true, jsonConvert, getLeisurePromise, left, right} = Runtime);
    ({Promise} = Bluebird);
    ({genSource, SourceNode, sourceNode, SourceMapConsumer, SourceMapGenerator, genMap, CodeGenerator, withFile, jsCodeFor, setDebugType} = Gen);
    ({dump} = Yaml);
    ({getCodeItems, blockSource, parseYaml} = DocOrg);
    ({mapStackTrace} = SourcemappedStackTrace);
    //########
    // init
    //########
    generatedFileCount = 0;
    defaultEnv.prompt = function(str, defaultValue, cont) {
      return cont(prompt(str, defaultValue));
    };
    currentGeneratedFileName = function() {
      return `notebook-${generatedFileCount}`;
    };
    nextGeneratedFileName = function() {
      generatedFileCount++;
      return currentGeneratedFileName();
    };
    requirePromise = function(file) {
      return new Promise(function(resolve, reject) {
        return requirejs([file], resolve);
      });
    };
    leisurePromise = null;
    getLeisurePromise = function() {
      if (!leisurePromise) {
        leisurePromise = requirePromise('./leisure/generatedPrelude').then(function() {
          return requirePromise('./leisure/std');
        }).then(function() {
          return requirePromise('./leisure/parseAst');
        }).then(function() {
          return requirePromise('./leisure/svg');
        }).then(function() {
          return new Promise(function(resolve, reject) {
            return simpleEval('resetStdTokenPacks', resolve, reject);
          });
        }).then(function() {
          return setDebugType('User');
        }).then(function() {
          return console.log("LOADED LEISURE");
        }).catch(function(err) {
          return console.error(`ERROR LOADING LEISURE SYSTEM!\n${err.stack}`);
        });
      }
      return leisurePromise;
    };
    callFail = function(fail, err) {
      if (fail) {
        return fail(err);
      } else {
        throw err;
      }
    };
    simpleEval = function(txt, success, fail) {
      var env, rejected;
      rejected = false;
      env = {
        __proto__: defaultEnv,
        errorAt: function(offset, msg) {
          if (!rejected) {
            rejected = true;
            return fail(msg);
          }
        }
      };
      return runMonad2(rz(L_newParseLine)(0, L_nil, txt), env, function(ast) {
        var err;
        if (getType(ast) !== 'err') {
          try {
            return runMonad2(eval(genSource(txt, ast)), env, function(x) {
              if (!rejected) {
                return success(x);
              }
            });
          } catch (error) {
            err = error;
            if (!rejected) {
              return callFail(fail, err);
            }
          }
        } else if (!rejected) {
          return fail(new Error(`Parse error: ${ast(id)}`));
        }
      });
    };
    //########
    // CODE
    //########
    defaultEnv.write = function(str) {
      return console.log(str);
    };
    defaultEnv.errorAt = function(offset, msg) {
      debugger;
      return console.log(msg);
    };
    id = lz(function(x) {
      return rz(x);
    });
    getLeft = getRight = function(x) {
      return x(id)(id);
    };
    show = function(obj) {
      if (typeof L_show !== "undefined" && L_show !== null) {
        return rz(L_show)(lz(obj));
      } else {
        return console.log(obj);
      }
    };
    (typeof window !== "undefined" && window !== null ? window : global).evalLeisure = evalLeisure = function(str, cont) {
      var env;
      //console.log "EVAL: \n#{str}"
      env = leisureEnv({
        __proto__: defaultEnv
      });
      env.presentValue = function(v) {
        return v;
      };
      return env.executeText(str, Nil, cont);
    };
    runLeisureMonad = function(value, cont) {
      var env;
      env = leisureEnv({
        __proto__: defaultEnv,
        opts: defaultEnv.opts
      });
      env.presentValue = function(v) {
        return v;
      };
      return runMonad2(value, env, cont);
    };
    // force Chrome to register this source file by compiling dummy JS code associated with the file
    defineSourceFile = function(fileName, contents) {
      addSourceFile(fileName, contents);
      return eval(jsCodeFor(codeMap(new SourceNode(1, 0, fileName, 'void(0)'), contents, fileName, true)));
    };
    ErrorCache = class ErrorCache {
      constructor(limit = 10) {
        this.limit = limit;
        this.cacheArray = [];
        this.cacheSet = {};
      }

      addError(err) {
        var e;
        while (this.cacheArray.length >= this.limit) {
          e = this.cacheArray.shift();
          delete this.cacheSet[e.cacheId];
        }
        err.cacheId = `errorid${Math.round(Math.abs(Math.random() * 1000000000))}`;
        this.cacheSet[err.cacheId] = err;
        this.cacheArray.push(err);
        return err.cacheId;
      }

    };
    errCache = new ErrorCache;
    Leisure.errCache = errCache.cacheSet;
    leisureErrorHtml = function(err) {
      return `<span class='error'>Error computing value: ${err.stack.replace(/\n/g, '<br>')}</span>`;
    };
    leisureEnv = function(env) {
      env.presentValue = function(v) {
        var err, str;
        try {
          str = v instanceof Error || ((v != null ? v.stack : void 0) != null) ? leisureErrorHtml(v) : rz(L_showHtml)(lz(v));
        } catch (error) {
          err = error;
          str = leisureErrorHtml(err);
        }
        return html(str);
      };
      env.executeText = function(text, props, cont) {
        return setLounge(this, () => {
          var opts;
          if (opts = this.opts) {
            console.log("OPTS:", opts);
          }
          return getLeisurePromise().then((() => {
            if (!this.opts) {
              this.opts = opts;
            }
            return leisureExec(this, text, props, ((result) => {
              var r;
              r = result.head().tail();
              if (getType(r) === 'left') {
                throw new Error(getLeft(r));
              } else {
                r = getRight(r);
                return typeof cont === "function" ? cont(r) : void 0;
              }
            }));
          })).catch((err) => {
            var ref;
            this.errorAt(0, (ref = err != null ? err.message : void 0) != null ? ref : err);
            console.error(e);
            return console.error(`Leisure text: ${text}`);
          });
        });
      };
      env.XexecuteText = function(text, props, cont) {
        return setLounge(this, function() {
          var opts;
          if (!cont) {
            cont = function(x) {
              var r;
              r = x.head().tail();
              if (getType(r) === 'left') {
                return new Error(getLeft(r));
              } else {
                return getRight(r);
              }
            };
          }
          if (getLeisurePromise().isResolved()) {
            return leisureExec(env, text, props, cont, function(err) {
              var ref;
              return env.errorAt(0, (ref = err != null ? err.message : void 0) != null ? ref : err);
            });
          } else {
            if (opts = env.opts) {
              console.log("OPTS:", opts);
            }
            return getLeisurePromise().then((() => {
              if (!env.opts) {
                env.opts = opts;
              }
              return leisureExec(env, text, props, cont, function(err) {
                var ref;
                return env.errorAt(0, (ref = err != null ? err.message : void 0) != null ? ref : err);
              });
            }), function(err) {
              var ref;
              return env.errorAt(0, (ref = err != null ? err.message : void 0) != null ? ref : err);
            });
          }
        });
      };
      env.formatResult = function(block, prefix, items) {
        return basicFormat(block, prefix, [this.presentValue(items)]);
      };
      env.genBlock = function(block, cont) {
        return this.generateCode(blockSource(block), true, cont);
      };
      env.executeBlock = function(block, cont) {
        return runWithPromiseCont(((c) => {
          return this.genBlock(block, c);
        }), function(results) {
          var j, len, result;
          results = arrayify(results);
          for (j = 0, len = results.length; j < len; j++) {
            result = results[j];
            if (result instanceof Error) {
              return mapErrors(results, cont);
            }
          }
          return cont(results);
        });
      };
      env.generateCode = function(text, noFunc, cont) {
        return setLounge(this, () => {
          var exec, fileName;
          fileName = currentGeneratedFileName();
          exec = () => {
            env.fileName = fileName;
            defineSourceFile(fileName, text);
            return leisureExec(this, text, L_nil, (function(result) {
              var asts, errs, results;
              env.fileName = null;
              errs = [];
              results = [];
              //asts = _.map result.toArray(), (el)-> el.head()
              asts = _.map(result.toArray(), function(el) {
                if (getType(el.tail()) === 'left') {
                  errs.push(getLeft(el.tail()));
                } else if (cont) {
                  results.push(getRight(el.tail()));
                }
                return el.head();
              });
              if (errs.length) {
                return typeof cont === "function" ? cont(errs[0]) : void 0;
              } else {
                return withFile(fileName, null, function() {
                  var code, gen, item, node;
                  if (typeof cont === "function") {
                    cont(results);
                  }
                  code = (function() {
                    var j, len, results1;
                    results1 = [];
                    for (j = 0, len = asts.length; j < len; j++) {
                      item = asts[j];
                      gen = new CodeGenerator(fileName, false, true, false, text);
                      node = gen.genNode(item);
                      results1.push(sourceNode(item, 'function(){return ', node, ';}'));
                    }
                    return results1;
                  })();
                  node = new SourceNode(1, 0, fileName, ['"use strict";\n', (!noFunc ? '(function(cont){return ' : []), 'L_runMonads([\n    ', intersperse(code, ',\n    '), (!noFunc ? '\n  ], null, cont)' : '\n  ])'), (!noFunc ? ';})' : [])]);
                  return codeMap(node, text, fileName, true);
                });
              }
            }), function(err) {
              throw err;
            });
          };
          if (getLeisurePromise().isResolved()) {
            return exec();
          } else {
            return getLeisurePromise().then(exec);
          }
        });
      };
      env.userEvent = function() {
        return flushTraceLog();
      };
      env.compileBlock = function(block) {
        var p;
        p = this.generateCode(blockSource(block));
        if (p instanceof Promise) {
          return p.then(function(result) {
            return eval(codeFor(result));
          });
        } else {
          return eval(codeFor(p));
        }
      };
      return env;
    };
    mapErrors = function(results, cont) {
      var result;
      return Promise.all((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = results.length; j < len; j++) {
          result = results[j];
          results1.push(result instanceof Error ? (function(result) { //&& false
            return new Promise(function(succeed, fail) {
              return mapStackTrace(result.stack, function(r) {
                var frame, tidyFrames;
                tidyFrames = (function() {
                  var k, len1, results2;
                  results2 = [];
                  for (k = 0, len1 = r.length; k < len1; k++) {
                    frame = r[k];
                    results2.push(frame.replace(/^   */, '  ').replace(/\([^\/][^)]*\)/, function(s) {
                      return `(${new URL(s.substring(1, s.length - 1), location)})`;
                    }));
                  }
                  return results2;
                })();
                return succeed({
                  stack: tidyFrames.join('\n')
                });
              });
            });
          })(result) : result);
        }
        return results1;
      })()).then(function(newResults) {
        return cont(newResults);
      });
    };
    runWithPromiseCont = function(func, cont) {
      var err, failPromise, res, succeedPromise, sync;
      sync = false;
      res = null;
      succeedPromise = null;
      failPromise = null;
      try {
        func(function(result) {
          sync = true;
          if (succeedPromise) {
            cont(result);
            return succeedPromise(result);
          } else {
            return res = result;
          }
        });
        if (sync) {
          cont(res);
          return res;
        } else {
          return new Promise(function(resolve, reject) {
            succeedPromise = resolve;
            return failPromise = reject;
          });
        }
      } catch (error) {
        err = error;
        if (failPromise) {
          return failPromise(err);
        } else {
          throw err;
        }
      }
    };
    codeFor = function(codeObject) {
      if (typeof codeObject === 'string') {
        return codeObject;
      } else if (codeObject.map != null) {
        return jsCodeFor(codeObject);
      } else {
        return codeObject.code;
      }
    };
    codeMap = function(sourceNode, content, fileName, tagContext) {
      var cm;
      fileName = fileName != null ? fileName : currentGeneratedFileName();
      cm = sourceNode.toStringWithSourceMap({
        file: fileName
      });
      cm.map.setSourceContent(fileName, content);
      if (tagContext) {
        cm.useContext = true;
      }
      return cm;
    };
    sourceNodeFromCodeMap = function(codeMap) {
      return SourceNode.fromStringWithSourceMap(codeMap.code, new SourceMapConsumer(codeMap.map.toJSON()));
    };
    joinSourceMaps = function(...args) {
      return new SourceNode(1, 0, '', Array.prototype.slice.call(args));
    };
    composeSourceMaps = function(...args) {
      var j, map, ref, result;
      result = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(_.last(args)));
      ref = args.slice(0, +(args.length - 2) + 1 || 9e9);
      for (j = ref.length - 1; j >= 0; j += -1) {
        map = ref[j];
        result.applySourceMap(new SourceMapConsumer(map));
      }
      return result.toJSON();
    };
    intersperse = function(array, element) {
      var i, j, ref, result;
      if (array.length < 2) {
        return array;
      } else {
        result = [array[0]];
        for (i = j = 1, ref = array.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
          result.push(element, array[i]);
        }
        return result;
      }
    };
    leisureExec = function(env, text, props, cont, errCont) {
      var err, old;
      try {
        old = getValue('parser_funcProps');
        setValue('parser_funcProps', props);
        return setLounge(env, () => {
          var result;
          result = rz(L_baseLoadString)(nextGeneratedFileName(), text);
          return runMonad2(result, env, function(results) {
            return runNextResult(results, env, (function(finalResults) {
              setValue('parser_funcProps', old);
              return (cont != null ? cont : function(x) {
                return x;
              })(finalResults);
            }), errCont, []);
          });
        });
      } catch (error) {
        err = error;
        return callFail(errCont, err);
      }
    };
    runNextResult = function(results, env, cont, errCont, finalResults) {
      var async, err, sync, v;
      while (results !== rz(L_nil)) {
        if (getType(results.head().tail()) === 'left') {
          v = results.head().tail();
          if (!(getLeft(v) instanceof Error)) {
            v = left(new Error(getLeft(v)));
          }
          finalResults.push(cons(results.head().head(), v));
          env.write(`ERROR: ${getLeft(results.head().tail())}`);
        } else {
          sync = true;
          async = true;
          try {
            setLounge(env, () => {
              return runMonad2(getRight(results.head().tail()), env, function(res2) {
                finalResults.push(cons(results.head().head(), L_right(res2)));
                //if getType(res2) != 'unit' then env.write env.presentValue res2
                if (sync) {
                  return async = false;
                } else {
                  return runNextResult(results.tail(), env, cont, errCont, finalResults);
                }
              });
            });
          } catch (error) {
            err = error;
            callFail(errCont, err);
          }
          sync = false;
          if (async) {
            return;
          }
        }
        results = results.tail();
      }
      return cont(newConsFrom(finalResults));
    };
    hasCodeAttribute = function(block, attr, value) {
      var a, ref, ref1, ref2, word;
      if (block.attributeWords == null) {
        block.attributeWords = {};
      }
      if (!block.attributeWords[attr]) {
        a = (ref = (ref1 = block.codeAttributes) != null ? ref1[attr] : void 0) != null ? ref : [];
        if (!_.isArray(a)) {
          a = a.split(' ');
        }
        block.attributeWords[attr] = (function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = a.length; j < len; j++) {
            word = a[j];
            results1.push(word.toLowerCase());
          }
          return results1;
        })();
      }
      return ref2 = value.toLowerCase(), indexOf.call(block.attributeWords[attr], ref2) >= 0;
    };
    isYamlResult = function(block) {
      var ref;
      return hasCodeAttribute(block, 'results', 'yaml') || ((ref = block.language) === 'text' || ref === 'string' || ref === 'yaml');
    };
    presentHtml = function(v) {
      var str;
      str = ': ' + (v instanceof Html ? v.content.replace(/\r?\n/g, '\\n') : escapeHtml(stringFor(v).replace(/\r?\n/g, '\n: ')));
      if (_.last(str) === '\n') {
        return str;
      } else {
        return str + '\n';
      }
    };
    basicFormat = function(block, prefix, items) {
      var ref;
      if (isYamlResult(block)) {
        if (items.length === 1) {
          items = items[0];
        }
        return ': ' + (dump(items, {
          sortKeys: true,
          flowLevel: Number((ref = block.codeAttributes.flowlevel) != null ? ref : 2)
        })).trim().replace(/\n/g, '\n: ') + '\n';
      } else {
        return prefix + _.map(items, presentHtml).join('');
      }
    };
    arrayify = function(val) {
      if (_.isArray(val)) {
        return val;
      } else {
        return [val];
      }
    };
    writeResults = function(env, values) {
      var first, j, len, ref, results1, value;
      first = true;
      ref = arrayify(values);
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        value = ref[j];
        if (!first) {
          env.write('\n');
        }
        results1.push(env.write(env.presentValue(value)));
      }
      return results1;
    };
    defaultEnv.formatResult = function(block, prefix, items) {
      return basicFormat(block, prefix, items);
    };
    setLounge = function(env, func) {
      var oldLounge, result;
      oldLounge = (typeof window !== "undefined" && window !== null ? window : global).Lounge;
      (typeof window !== "undefined" && window !== null ? window : global).Lounge = env;
      env.opts = env.opts;
      try {
        result = func();
      } finally {
        (typeof window !== "undefined" && window !== null ? window : global).Lounge = oldLounge;
      }
      return result;
    };
    textEnv = function(env) {
      env.executeText = function(text) {
        return text;
      };
      return env;
    };
    yamlEnv = function(env) {
      env.executeText = function(text) {
        return parseYaml(text);
      };
      return env;
    };
    jsEnv = function(env) {
      env.executeText = function(text, props, cont) {
        return setLounge(this, () => {
          return new Promise(function(succeed) {
            var value;
            writeResults(env, value = jsEval(env, text));
            succeed(value);
            return typeof cont === "function" ? cont(value) : void 0;
          }).catch((err) => {
            return this.errorAt(0, err.message);
          });
        });
      };
      env.generateCode = function(text) {
        var cm, fileName, nodes;
        fileName = nextGeneratedFileName();
        cm = codeMap(new SourceNode(1, 0, fileName, text), text, fileName);
        nodes = SourceNode.fromStringWithSourceMap(text, SourceMapConsumer.fromSourceMap(cm));
        return (new SourceNode(1, 0, fileName, ['function(){', nodes, '}'])).toStringWithSourceMap();
      };
      return env;
    };
    jsGatherSourceResults = function(env, text, map, fileName, src) {
      var code, column, err, err2, errNode, expr, exprText, j, len, line, name, newSource, oldNodes, parsed, ref, s, source;
      if (env.silent) {
        return text;
      } else {
        try {
          parsed = acorn.parse(text);
        } catch (error) {
          err = error;
          errNode = null;
          handleErrors(acornLoose.parse_dammit(text), function(node) {
            return errNode = node;
          });
          try {
            setLounge(env, function() {
              return eval(text);
            });
          } catch (error) {
            err2 = error;
            if (errNode) {
              env.errorAt(Math.min(errNode.start, errNode.end), err2.message);
            } else {
              env.errorAt(findError(err.message, text), err2.message);
            }
            return 'void 0';
          }
        }
        oldNodes = sourceNodeTree(SourceNode.fromStringWithSourceMap(text, map));
        newSource = ['var leisure_results=[];\n'];
        ref = parsed.body;
        for (j = 0, len = ref.length; j < len; j++) {
          expr = ref[j];
          ({line, column, source, name} = lineLocationForOffset(map, text, expr.start));
          if (expr.type === 'ExpressionStatement') {
            if (expr.expression.type !== 'ObjectExpression') {
              expr = expr.expression;
            }
            exprText = text.substring(expr.start, expr.end);
            if (exprText[exprText.length - 1] === ';') {
              expr = {
                start: expr.start,
                end: expr.end - 1
              };
            }
            if ((s = new SourceNode(line, column, source, nodesForGeneratedText(oldNodes, expr))).toString() !== text.substring(expr.start, expr.end)) {
              console.warn(`Source nodes don't line up:\n${s.toString()}`);
            }
            newSource.push(new SourceNode(line, column, source, ['\nleisure_results.push(', nodesForGeneratedText(oldNodes, expr), ');\n'], name));
          } else {
            newSource.push(new SourceNode(line, column, source, [text.substring(expr.start, expr.end)]));
          }
        }
        ({code, map} = new SourceNode(1, 0, fileName, newSource).toStringWithSourceMap());
        map.setSourceContent(fileName, src);
        return SourceNode.fromStringWithSourceMap(code, SourceMapConsumer.fromSourceMap(map));
      }
    };
    //new SourceNode 1, 0, fileName, newSource
    sourceNodeTree = function(nodes) {
      var entryArray;
      entryArray = [];
      nodes.walk(function(code, node) {
        return entryArray.push([code, node]);
      });
      return FingerTree.fromArray(entryArray, {
        measure: function(n) {
          return n[0].length;
        },
        identity: function() {
          return 0;
        },
        sum: function(a, b) {
          return a + b;
        }
      });
    };
    nodesForGeneratedText = function(nodeTree, {start, end}) {
      var code, endPos, j, len, node, preceding, ref, result, startLen, target;
      result = [];
      [preceding, target] = nodeTree.split(function(m) {
        return m > start;
      });
      startLen = preceding.measure();
      if (!preceding.isEmpty()) {
        [code, node] = preceding.peekLast();
        result.push(sn(node, code.substring(start - startLen)));
      }
      [preceding, target] = target.split(function(m) {
        return startLen + m > end;
      });
      if (!preceding.isEmpty() || !target.isEmpty()) {
        ref = preceding.toArray();
        for (j = 0, len = ref.length; j < len; j++) {
          [code, node] = ref[j];
          result.push(sn(node, code));
        }
        if (!target.isEmpty()) {
          endPos = startLen + preceding.measure();
          [code, node] = target.peekFirst();
          result.push(sn(node, code.substring(0, end - endPos)));
        }
      }
      return result;
    };
    sn = function({line, column, source}, code) {
      return new SourceNode(line, column, source, code);
    };
    lineLocationForOffset = function(map, str, offset) {
      var line, next, pos;
      line = 1;
      pos = -1;
      while ((next = str.indexOf('\n', pos + 1)) < offset && next !== -1) {
        pos = next;
        line++;
      }
      return map.originalPositionFor({
        line,
        column: offset - pos + 1
      });
    };
    jsGatherResults = function(env, text, returnResults) {
      var err, err2, errNode, expr, exprText, j, len, newText, parsed, ref;
      try {
        parsed = acorn.parse(text);
      } catch (error) {
        err = error;
        errNode = null;
        handleErrors(acornLoose.parse_dammit(text), function(node) {
          return errNode = node;
        });
        try {
          setLounge(env, function() {
            return eval(text);
          });
        } catch (error) {
          err2 = error;
          if (errNode) {
            env.errorAt(Math.min(errNode.start, errNode.end), err2.message);
          } else {
            env.errorAt(findError(err.message, text), err2.message);
          }
          return 'void 0';
        }
      }
      if (env.silent) {
        return text;
      } else {
        newText = 'var leisure_results=[];\n';
        ref = parsed.body;
        for (j = 0, len = ref.length; j < len; j++) {
          expr = ref[j];
          if (expr.type === 'ExpressionStatement') {
            exprText = text.substring(expr.start, expr.end);
            if (exprText[exprText.length - 1] === ';') {
              exprText = exprText.substring(0, exprText.length - 1);
            }
            newText = `${newText.trim()}\nleisure_results.push(${exprText.trim()});\n`;
          } else {
            newText += text.substring(expr.start, expr.end);
          }
        }
        return `${newText}${(returnResults ? ';\nreturn leisure_results' : '')}`;
      }
    };
    jsBaseEval = function(env, text) {
      var console;
      if (!env.silent) {
        env.results = [];
      }
      console = {
        log: (str) => {
          return env.write(env.presentValue(str));
        }
      };
      return setLounge(env, function() {
        if (env.eval) {
          return env.eval(text);
        } else {
          return localEval;
        }
      });
    };
    jsEval = function(env, text) {
      return jsBaseEval(env, jsGatherResults(env, text));
    };
    //jsEval = (env, text)-> (jsBaseEval env, "(function(){" + jsGatherResults(env, text, true) + "})").call(env)
    findError = function(err, text) {
      var col, j, len, line, n, ref, tot, txt, x;
      [x, line, col] = err.match(/\(([0-9]*):([0-9]*)\)/);
      line = Number(line - 1);
      tot = Number(col);
      ref = text.split('\n');
      for (n = j = 0, len = ref.length; j < len; n = ++j) {
        txt = ref[n];
        if (n === line) {
          break;
        } else {
          tot += txt.length + 1;
        }
      }
      return tot;
    };
    walk = (typeof window !== "undefined" && window !== null ? window : global).Walk = function(node, func) {
      var type, v;
      v = {};
      for (type in acornWalk.base) {
        v[type] = func;
      }
      return acornWalk.simple(node, v, null);
    };
    isError = function(node) {
      return node.name === "âœ–";
    };
    handleErrors = function(ast, func) {
      return walk(ast, function(node) {
        if (isError(node)) {
          return func(node);
        }
      });
    };
    lsEnv = function(env) {
      env.executeText = function(text, props, cont) {
        return setLounge(this, () => {
          var console, err, value;
          try {
            console = {
              log: (str) => {
                return env.write(env.presentValue(str));
              }
            };
            value = setLounge(env, function() {
              return eval(lispyScript._compile(text));
            });
            if (typeof value !== 'undefined') {
              writeResults(env, [value]);
            }
          } catch (error) {
            err = error;
            this.errorAt(0, err.message);
          }
          return typeof cont === "function" ? cont(value) : void 0;
        });
      };
      return env;
    };
    csEnv = function(env) {
      env.executeText = function(text, props, cont) {
        return setLounge(this, () => {
          return new Promise((succeed) => {
            var values;
            writeResults(env, values = this.runWith({}, eval(`(function(){${this.blockCode(text, null, null, null, true)}})`)));
            succeed(values != null ? values : []);
            return typeof cont === "function" ? cont(values != null ? values : []) : void 0;
          }).catch(function(err) {
            var ref;
            console.error((ref = err.stack) != null ? ref : err);
            return env.errorAt(0, err.message);
          });
        });
      };
      env.executeBlock = function(block, cont) {
        return new Promise((succeed) => {
          return this.compileBlock(block).call(this, function(result) {
            succeed(result);
            return typeof cont === "function" ? cont(result) : void 0;
          });
        }).catch(function(err) {
          var ref;
          console.error((ref = err.stack) != null ? ref : err);
          return env.errorAt(0, err.message);
        });
      };
      env.compileBlock = function(block) {
        var code, fileName, nodes, ref, ref1, varMappings, varNames, vars;
        fileName = currentGeneratedFileName();
        ref1 = blockVars(this.data, (ref = block.codeAttributes) != null ? ref.var : void 0), [vars, varNames, varMappings] = slice.call(ref1, -3);
        nodes = new SourceNode(1, 0, fileName, ['(function(){', this.blockCode(blockSource(block), vars, varNames, varMappings, true, null, fileName, true), '})']);
        code = this.runWith({}, jsCodeFor(nodes.toStringWithSourceMap()));
        return function(cont, ...args) {
          var i, j, len, ref2, ret, varName;
          if (this !== (typeof window !== "undefined" && window !== null ? window : global)) {
            this.ctx = {
              _blocks: {}
            };
            for (i = j = 0, len = varNames.length; j < len; i = ++j) {
              varName = varNames[i];
              this.ctx[varName] = (ref2 = args[i]) != null ? ref2 : this.data.getYaml(this.data.getBlockNamed(varMappings[varName]));
              if (!args[i]) {
                this.ctx._blocks[varName] = this.data.getBlockNamed(varMappings[varName]);
              }
            }
          }
          ret = code.apply(this, args);
          if (cont) {
            return cont(ret);
          } else {
            return ret;
          }
        };
      };
      env.genBlock = function(block, vars, varNames, varMappings) {
        var fileName, nodes, ref, ref1;
        ref1 = blockVars(this.data, (ref = block.codeAttributes) != null ? ref.var : void 0), [vars, varNames, varMappings] = slice.call(ref1, -3);
        fileName = nextGeneratedFileName();
        nodes = new SourceNode(1, 0, fileName, ['(function(){', this.blockCode(blockSource(block), vars, varNames, varMappings, false, null, fileName, true), '})']);
        return nodes.toStringWithSourceMap();
      };
      env.blockCode = function(src, vars, varNames, varMappings, useReturn, noGather, fileName, sourceNodes) {
        var blockVarStr, blocks, con, constName, constStr, consts, js, name, nodes, output, ref, smGen, v3SourceMap, value, varName;
        fileName = fileName != null ? fileName : currentGeneratedFileName();
        vars = vars != null ? vars : {};
        varNames = varNames != null ? varNames : [];
        varMappings = varMappings != null ? varMappings : {};
        blocks = {};
        consts = {};
        for (name in vars) {
          value = vars[name];
          if (Number(value) === value || (ref = value[0], indexOf.call("'\"", ref) >= 0)) {
            consts[name] = value;
          } else {
            blocks[name] = value;
          }
        }
        constStr = ((function() {
          var results1;
          results1 = [];
          for (constName in consts) {
            value = consts[constName];
            results1.push(`  if (${constName} == undefined) ${constName} = ${value};\n`);
          }
          return results1;
        })()).join('');
        blockVarStr = ((function() {
          var results1;
          results1 = [];
          for (varName in varMappings) {
            value = varMappings[varName];
            results1.push(`  ${varName} = this.ctx.${varName} || this.data.getYaml(this.data.getBlockNamed('${value}'));\n`);
          }
          return results1;
        })()).join('');
        ({js, v3SourceMap} = CS.compile(src, {
          bare: true,
          sourceMap: true,
          sourceFiles: [fileName]
        }));
        smGen = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(JSON.parse(v3SourceMap)));
        smGen.setSourceContent(fileName, src);
        con = SourceMapConsumer.fromSourceMap(smGen);
        output = !noGather && !env.silent ? [jsGatherSourceResults(this, js, con, fileName, src)] : [SourceNode.fromStringWithSourceMap(js, con)];
        output.unshift(`${constStr}${blockVarStr}\n`);
        if (!env.silent && !noGather) {
          if (useReturn) {
            output.push('return ');
          }
          output.push('typeof __cont != "undefined" ? __cont(leisure_results) : leisure_results;\n');
        }
        nodes = new SourceNode(1, 0, fileName, output);
        if (sourceNodes) {
          return nodes;
        } else {
          return jsCodeFor(nodes.toStringWithSourceMap());
        }
      };
      env.generateCode = function(text) {
        var fileName, js, nodes, smGen, v3SourceMap;
        fileName = currentGeneratedFileName();
        ({js, v3SourceMap} = CS.compile(text, {
          bare: true,
          sourceMap: true,
          sourceFiles: [fileName]
        }));
        smGen = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(JSON.parse(v3SourceMap)));
        smGen.setSourceContent(fileName, text);
        nodes = SourceNode.fromStringWithSourceMap(js, SourceMapConsumer.fromSourceMap(smGen));
        return (new SourceNode(1, 0, fileName, ['function(){', nodes, '}'])).toStringWithSourceMap();
      };
      return env;
    };
    //jsCodeFor = (codeMap)->
    //  #"#{codeMap.code}\n"
    //  "#{codeMap.code}\n//# sourceMappingURL=data:application/json;base64,#{btoa JSON.stringify codeMap.map.toJSON()}\n"
    indentCode = function(str) {
      return str.replace(/\n/g, '\n  ');
    };
    stringFor = function(v) {
      var str;
      str = typeof v === 'function' ? v.toString() || 'UNKNOWN' : v.toString ? v.toString() : String(v);
      if (typeof str === 'string') {
        return str;
      } else {
        return 'undefined';
      }
    };
    Html = class Html {
      constructor(content) {
        this.content = stringFor(content);
      }

    };
    html = function(content) {
      return new Html(content);
    };
    errorDiv = function(err, orgText) {
      return `<span class='error' contenteditable='false'><span class='hidden'>${orgText || ''}</span><span data-nonorg='true'>${escapeHtml(err)}</span></span>`;
    };
    replacements = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '"': '&quot;',
      "'": '&#39;'
    };
    escapeHtml = function(str) {
      if (typeof str === 'string') {
        return str.replace(/[<>&\'\"]/g, function(c) {
          return replacements[c];
        });
      } else {
        return str;
      }
    };
    knownLanguages = {
      leisure: leisureEnv,
      javascript: jsEnv,
      js: jsEnv,
      lisp: lsEnv,
      cs: csEnv,
      coffee: csEnv,
      coffeescript: csEnv,
      text: textEnv,
      string: textEnv,
      yaml: yamlEnv
    };
    envTemplate = {
      executeText: null,
      executeBlock: null,
      generateCode: null,
      compileBlock: null
    };
    // ## Scope class
    Scope = class Scope {
      constructor() {
        this.names = [];
        this.nameSet = {};
        this.setters = {};
        this.getters = {};
        this.eval = eval(newEvalFuncString());
      }

      newNames(names) {
        var code, j, len, n, name, newNames, totalNames;
        newNames = _.without(names, ...this.names);
        totalNames = newNames.concat(_.without(this.names, ...names));
        if (!_.isEmpty(newNames)) {
          for (j = 0, len = newNames.length; j < len; j++) {
            name = newNames[j];
            this.nameSet[name] = true;
          }
          code = `${((function() {
            var k, len1, results1;
            results1 = [];
            for (k = 0, len1 = newNames.length; k < len1; k++) {
              n = newNames[k];
              results1.push('var ' + n + ' = null;');
            }
            return results1;
          })()).join('\n  ')}\n\n(${newEvalFuncString()})`;
          this.names = totalNames;
          return this.eval = this.eval(code);
        }
      }

      get(name) {
        var g;
        if (!this.nameSet[name]) {
          throw new Error(`No member of namespace named '${name}'`);
        }
        if (!(g = this.getters[name])) {
          g = this.getters[name] = this.eval(`(function() {return ${name};})`);
        }
        return g();
      }

      set(name, value) {
        var s;
        if (!this.nameSet[name]) {
          throw new Error(`No member of namespace named '${name}'`);
        }
        if (!(s = this.setters[name])) {
          s = this.setters[name] = this.eval(`(function($v$) {${name} = $v$})`);
        }
        return s(value);
      }

    };
    gensymCounter = 0;
    gensym = function(prefix) {
      return `$L_${prefix}_${gensymCounter++}$`;
    };
    newEvalFuncString = function() {
      var evalVar;
      evalVar = gensym("EXPR");
      return `(function(${evalVar}) {return eval(${evalVar})})`;
    };
    installEnv = function(names, func) {
      var j, langName, len, results1;
      results1 = [];
      for (j = 0, len = names.length; j < len; j++) {
        langName = names[j];
        results1.push(knownLanguages[langName] = func);
      }
      return results1;
    };
    autoLoadProperty = function(env, names, property, libraryName, cont) {
      return env[property] = function(...args) {
        if (!knownLanguages[names[0]].autoLoad) {
          return env[property](...args);
        } else {
          return requirePromise(libraryName).then(function(installFunc) {
            var res;
            res = installFunc(env);
            if (knownLanguages[names[0]].autoLoad) {
              if (res instanceof Promise) {
                return res.then(function(envFunc) {
                  return installEnv(names, envFunc);
                });
              } else {
                return installEnv(names, res);
              }
            }
          }).then(function() {
            //debugger
            return env[property](...args);
          }).catch(function(err) {
            return env.errorAt(0, err.message);
          });
        }
      };
    };
    autoLoadEnv = function(names, libraryName) {
      var func;
      names = _.map((_.isArray(names) ? names : [names]), function(n) {
        return n.toLowerCase();
      });
      func = function(env) {
        var prop;
        for (prop in envTemplate) {
          autoLoadProperty(env, names, prop, libraryName);
        }
        return env;
      };
      func.autoLoad = true;
      return installEnv(names, func);
    };
    localEval = function($x$) {
      return eval($x$);
    };
    languageEnvMaker = function(name) {
      return knownLanguages[name != null ? name.toLowerCase() : void 0];
    };
    blocksObserved = function(block) {
      var j, len, ob, ref, results1;
      ref = block.observing;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        ob = ref[j];
        if (ob.match(/^block\./)) {
          results1.push(ob.replace(/^block\./, ''));
        }
      }
      return results1;
    };
    blockVars = function(data, varDefs) {
      var bl, blockIds, blockNames, def, name, v, value, varMappings, varNames, vars;
      blockIds = {};
      blockNames = {};
      vars = {};
      varMappings = {};
      varNames = (function() {
        var j, len, ref, ref1, ref2, results1;
        if (varDefs) {
          ref = (_.isArray(varDefs) ? varDefs : [varDefs]);
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            v = ref[j];
            ref1 = v.match(/^([^=]*)(=(.*))?$/), [name, def, value] = slice.call(ref1, -3);
            name = name.trim();
            if (!def) {
              value = name;
            }
            if (ref2 = value[0], indexOf.call("'\"0123456789", ref2) >= 0) {
              value = JSON.parse(value);
            } else {
              varMappings[name] = value;
              if (bl = data.getBlockNamed(value)) {
                blockIds[bl._id] = true;
                value = data.getYaml(bl);
              }
              blockNames[name] = value;
            }
            //else value = value.trim()
            vars[name] = value;
            results1.push(name);
          }
          return results1;
        }
      })();
      return [vars, _.keys(blockIds), blockNames, varNames != null ? varNames : [], varMappings];
    };
    escaped = {
      '\b': "\\b",
      '\f': "\\f",
      '\n': "\\n",
      '\r': "\\r",
      '\t': "\\t",
      '\v': "\\v",
      '\"': "\\\"",
      '\\': "\\\\"
    };
    unescaped = _.invert(escaped);
    specials = /[\b\f\n\r\t\v\"\\]/g;
    slashed = /\\./g;
    escapeString = function(str) {
      return stringFor(str).replace(specials, function(c) {
        return escaped[c];
      });
    };
    unescapeString = function(str) {
      return stringFor(str).replace(slashed, function(c) {
        var ref;
        return (ref = unescaped[c]) != null ? ref : c[1];
      });
    };
    lineColumnStrOffset = function(str, line, column) {
      var newPos, pos;
      pos = -1;
      while (line-- > 0) {
        newPos = str.indexOf('\n', pos);
        if (newPos < pos) {
          return str.length;
        }
        pos = newPos + 1;
      }
      return Math.min(str.length, pos + 1 + column);
    };
    Object.assign(Leisure, {evalLeisure, runLeisureMonad, setLounge, joinSourceMaps, codeMap, sourceNodeFromCodeMap, composeSourceMaps, SourceNode, SourceMapConsumer, SourceMapGenerator, autoLoadEnv, languageEnvMaker, Scope});
    return {languageEnvMaker, html, Html, escapeHtml, blockVars, blocksObserved, knownLanguages, presentHtml, escapeString, unescapeString, evalLeisure, runLeisureMonad, setLounge, hasCodeAttribute, isYamlResult, nextGeneratedFileName, getLeisurePromise, autoLoadEnv, Scope, lineColumnStrOffset, writeResults, runWithPromiseCont};
  });

}).call(this);

//# sourceMappingURL=eval.js.map

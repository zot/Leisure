// Generated by CoffeeScript 2.4.1
(function() {
  /*
  Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

  (licensed with ZLIB license)

  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
  claim that you wrote the original software. If you use this software
  in a product, an acknowledgment in the product documentation would be
  appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must not be
  misrepresented as being the original software.

  3. This notice may not be removed or altered from any source distribution.
  */
  
  // Parse orgmode files

  // alText() gets its text, plus its childrens'

  'use strict';
  define(['lib/lazy'], function(Lazy) {
    var ATTR_NAME, AttrHtml, DRAWER_NAME, Drawer, END_NAME, Example, Fragment, HL_LEVEL, HL_PRIORITY, HL_TAGS, HL_TEXT, HL_TODO, HTML, HTML_INFO, HTML_START_NAME, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, LINK_DESCRIPTION, LINK_HEAD, LINK_INFO, LIST_BOILERPLATE, LIST_CHECK, LIST_CHECK_VALUE, LIST_INFO, LIST_LEVEL, Link, ListItem, Meat, MeatParser, Node, PROPERTY_KEY, PROPERTY_VALUE, RES_NAME, Results, SRC_BOILERPLATE, SRC_INFO, SRC_NAME, SimpleMarkup, Source, UnknownDeclaration, _, attrHtmlLineRE, attrHtmlRE, buildHeadlineRE, checkMatch, declRE, drawerRE, endRE, exampleEndRE, exampleStartRE, fullLine, headlineRE, htmlEndRE, htmlStartRE, imagePathRE, inListItem, keywordPropertyRE, keywordRE, last, leisurePathRE, lineBreakPat, linkRE, listContentOffset, listRE, markupText, markupTypes, matchLine, meatStart, nextOrgNode, parseAttr, parseCodeAttributes, parseDrawer, parseExample, parseHeadline, parseHtmlBlock, parseKeyword, parseList, parseMeat, parseOrgChunk, parseOrgMode, parseRestOfMeat, parseResults, parseSrcBlock, parseTags, parseUnknown, propertyRE, resultsLineRE, resultsRE, simpleRE, srcEndRE, srcStartRE, tagsRE, todoKeywords, todoRE;
    ({_} = Lazy);
    todoKeywords = ['TODO', 'DONE'];
    declRE = /^#\+.*$/m;
    buildHeadlineRE = function() {
      return new RegExp(`^(\\*+( +|$))((?:${todoKeywords.join('|')}) *)?(\\[#(A|B|C)\\] *)?([^\\n]*?)(:[\\w@%#:]*: *)?$`, 'm');
    };
    HL_LEVEL = 1;
    HL_TODO = 3;
    HL_PRIORITY = 5;
    HL_TEXT = 6;
    HL_TAGS = 7;
    headlineRE = buildHeadlineRE();
    todoRE = /^(\*+) *(TODO|DONE)/;
    tagsRE = /:[^:]*/;
    KW_BOILERPLATE = 1;
    KW_NAME = 2;
    KW_INFO = 3;
    keywordRE = /^(#\+([^:\[\n]+)(?:\[.*\] *)?: *)([^\n]*)$/im;
    SRC_BOILERPLATE = 1;
    SRC_NAME = 2;
    SRC_INFO = 3;
    srcStartRE = /^(#\+(BEGIN_SRC) +)([^\n]*)$/im;
    END_NAME = 1;
    srcEndRE = /^#\+(END_SRC)( *)$/im;
    exampleStartRE = /^#\+BEGIN_EXAMPLE *$/im;
    exampleEndRE = /^#\+END_EXAMPLE *$/im;
    RES_NAME = 1;
    resultsRE = /^#\+(RESULTS)(?: *\[.*\] *)?: *$/im;
    resultsLineRE = /^([:|] .*)(?:\n|$)/i;
    DRAWER_NAME = 1;
    drawerRE = /^ *:([^\n:]*): *$/im;
    endRE = /^ *:END: *$/im;
    PROPERTY_KEY = 1;
    PROPERTY_VALUE = 2;
    propertyRE = /^ *:([^\n:]+): *([^\n]*)$/img;
    LIST_LEVEL = 1;
    LIST_BOILERPLATE = 2;
    LIST_CHECK = 3;
    LIST_CHECK_VALUE = 4;
    LIST_INFO = 5;
    listRE = /^( *)(- *)(\[( |X)\] +)?(.*)$/m;
    // markup characters: * / + = ~ _
    //simpleRE = /\B(\*[/+=~\w](.*?[/+=~\w])?\*|\/[*+=~\w](.*?[*+=~\w])?\/|\+[*/=~\w](.*?[*/=~\w])?\+|=[+*/~\w](.*?[+*/~\w])?=|~[=+*/\w](.*?[=+*/\w])?~)(\B|$)|\b_[^_]*\B_(\b|$)/
    //simpleRE = /\B(\*[/+=~\S](.*?[/+=~\S])?\*|\/[*+=~\S](.*?[*+=~\S])?\/|\+[*/=~\S](.*?[*/=~\S])?\+|=[+*/~\S](.*?[+*/~\S])?=|~[=+*/\S](.*?[=+*/\S])?~)(\B|$)|\b_[^_]*\B_(\b|$)/
    simpleRE = /\B(\*[^\s*]([^*]*[^\s*])?\*|\/[^\s\/]([^\/]*[^\s\/])?\/|\+[^\s+]([^+]*[^\s+])?\+|=[^\s=]([^=]*[^\s=])?=|~[^\s~]([^~]*[^\s~])?~)(\B|$)|\b_[^_]*\B_(\b|$)/;
    LINK_HEAD = 1;
    LINK_INFO = 2;
    LINK_DESCRIPTION = 3;
    linkRE = /(\[\[([^\]]*)\])(?:\[([^\]]*)\])?\]/;
    htmlStartRE = /^#\+(BEGIN_HTML\b)(.*)$/im;
    HTML_START_NAME = 1;
    HTML_INFO = 2;
    htmlEndRE = /^#\+END_HTML *$/im;
    ATTR_NAME = 1;
    attrHtmlRE = /^#\+(ATTR_HTML): *$/im;
    attrHtmlLineRE = /^([:|] .*)(?:\n|$)/i;
    imagePathRE = /\.(png|jpg|jpeg|gif|svg|tiff|bmp)$/i;
    leisurePathRE = /^(?:lounge|leisure):([^\/]*)(?:\/([^\/]*)(?:\/([^\/]*))?)?$/;
    keywordPropertyRE = /:([^ ]+)/;
    last = function(a) {
      return a[a.length - 1];
    };
    matchLine = function(txt) {
      var ref;
      if (((ref = txt.match(simpleRE)) != null ? ref.index : void 0) === 0) {
        return false;
      } else {
        return checkMatch(txt, exampleStartRE, 'exampleStart') || checkMatch(txt, exampleEndRE, 'exampleEnd') || checkMatch(txt, srcStartRE, 'srcStart') || checkMatch(txt, srcEndRE, 'srcEnd') || checkMatch(txt, resultsRE, 'results') || checkMatch(txt, attrHtmlRE, 'attr') || checkMatch(txt, keywordRE, 'keyword') || checkMatch(txt, headlineRE, function(m) {
          return `headline-${(m[HL_LEVEL].trim().length)}`;
        }) || checkMatch(txt, listRE, 'list') || checkMatch(txt, htmlStartRE, 'htmlStart') || checkMatch(txt, htmlEndRE, 'htmlEnd') || checkMatch(txt, declRE, 'unknownDecl');
      }
    };
    checkMatch = function(txt, pat, result) {
      var m;
      m = txt.match(pat);
      if ((m != null ? m.index : void 0) === 0) {
        if (typeof result === 'string') {
          return result;
        } else {
          return result(m);
        }
      } else {
        return false;
      }
    };
    Node = (function() {
      class Node {
        constructor() {
          this.markup = markupText(this.text);
        }

        count() {
          return 1;
        }

        length() {
          return this.text.length;
        }

        end() {
          return this.offset + this.text.length;
        }

        toJson() {
          return JSON.stringify(this.toJsonObject(), null, '  ');
        }

        toJsonObject() {
          var obj;
          obj = this.jsonDef();
          obj.nodeId = this.nodeId;
          return obj;
        }

        allText() {
          return this.text;
        }

        findNodeAt(pos) {
          if (this.offset <= pos && pos < this.offset + this.text.length) {
            return this;
          } else {
            return null;
          }
        }

        scan(func) {
          return func(this);
        }

        scanWithChildren(func) {
          var c, i, len, ref, results;
          func(this);
          ref = this.children;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            c = ref[i];
            results.push(c.scan(func));
          }
          return results;
        }

        linkNodes() {
          return this;
        }

        linkChild(child) {
          child.linkNodes();
          return child.linkTo(this);
        }

        linkChildren() {
          var c, i, len, prev, ref;
          prev = null;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            c = ref[i];
            if (prev) {
              prev.next = c;
            }
            this.linkChild(c);
            c.prev = prev;
            prev = c;
          }
          return this;
        }

        contains(node) {
          var ref;
          while (node) {
            if (node === this) {
              return true;
            }
            node = (ref = node.fragment) != null ? ref : node.parent;
          }
          return false;
        }

        top() {
          if (!this.parent) {
            return this;
          } else {
            return this.parent.top();
          }
        }

        toString() {
          return this.toJson();
        }

        allTags() {
          var ref, ref1;
          return (ref = (ref1 = this.parent) != null ? ref1.allTags() : void 0) != null ? ref : [];
        }

        allProperties() {
          var ref, ref1;
          return (ref = (ref1 = this.parent) != null ? ref1.allProperties() : void 0) != null ? ref : {};
        }

        linkTo(parent1) {
          this.parent = parent1;
        }

        fixOffsets(newOff) {
          this.offset = newOff;
          if (this.children) {
            return this.fixChildrenOffsets();
          } else {
            return newOff + this.allText().length;
          }
        }

        fixChildrenOffsets() {
          var child, i, len, offset, ref;
          offset = this.offset + this.text.length;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            offset = child.fixOffsets(offset);
          }
          return offset;
        }

        inNewMeat() {
          return false;
        }

        getRightmostDescendent() {
          var child, ref;
          child = this;
          while ((ref = child.children) != null ? ref.length : void 0) {
            child = child.children[child.children.length - 1];
          }
          return child;
        }

        getLeftmostDescendent() {
          var child, ref;
          child = this;
          while ((ref = child.children) != null ? ref.length : void 0) {
            child = child.children[0];
          }
          return child;
        }

        getPrecedingNode() {
          var parent, ref;
          if (this.prev) {
            return this.prev.getRightmostDescendent();
          } else if (parent = (ref = this.fragment) != null ? ref : this.parent) {
            if (parent.children[0] === this) {
              return parent;
            }
            return parent.children[parent.children.indexOf(this) - 1].getRightmostDescendent();
          }
        }

        getFollowingNode() {
          var parent, ref;
          if (this.next) {
            return this.next.getLeftmostDescendent();
          } else if (parent = (ref = this.fragment) != null ? ref : this.parent) {
            if (parent.children[parent.children.length - 1] === this) {
              return parent;
            }
            return parent.children[parent.children.indexOf(this) + 1].getLeftmostDescendent();
          }
        }

      };

      Node.prototype.block = false;

      Node.prototype.next = null;

      Node.prototype.prev = null;

      return Node;

    }).call(this);
    Headline = (function() {
      class Headline extends Node {
        constructor(text1, level1, todo1, priority1, tags1, children1, offset1) {
          super();
          this.text = text1;
          this.level = level1;
          this.todo = todo1;
          this.priority = priority1;
          this.tags = tags1;
          this.children = children1;
          this.offset = offset1;
          this.properties = {};
        }

        count() {
          var count, i, len, node, ref;
          count = 1;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            node = ref[i];
            count += node.count();
          }
          return count;
        }

        lowerThan(l) {
          return l < this.level;
        }

        length() {
          return this.end() - this.offset;
        }

        end() {
          var lastChild;
          if (this.children.length) {
            lastChild = this.children[this.children.length - 1];
            return lastChild.offset + lastChild.length();
          } else {
            return super.end();
          }
        }

        jsonDef() {
          var c;
          return {
            type: this.type,
            text: this.text,
            offset: this.offset,
            level: this.level,
            todo: this.todo,
            priority: this.priority,
            tags: this.tags,
            children: (function() {
              var i, len, ref, results;
              ref = this.children;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                c = ref[i];
                results.push(c.toJsonObject());
              }
              return results;
            }).call(this),
            properties: this.properties
          };
        }

        allText() {
          var c;
          return this.text + ((function() {
            var i, len, ref, results;
            ref = this.children;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              c = ref[i];
              results.push(c.allText());
            }
            return results;
          }).call(this)).join('');
        }

        findNodeAt(pos) {
          var child, i, len, ref, res;
          if (pos < this.offset || this.offset + this.length() < pos) {
            return null;
          } else if (pos < this.offset + this.text.length) {
            return this;
          } else {
            ref = this.children;
            // could binary search this
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (res = child.findNodeAt(pos)) {
                return res;
              }
            }
            return null;
          }
        }

        linkNodes() {
          return this.linkChildren();
        }

        addTags(set) {
          var i, len, ref, tag;
          ref = parseTags(this.tags);
          for (i = 0, len = ref.length; i < len; i++) {
            tag = ref[i];
            set[tag] = true;
          }
          return set;
        }

        addProperties(props) {
          return Object.assign(props, this.properties);
        }

        addAllTags() {
          var ref;
          return this.addTags(((ref = this.parent) != null ? ref.addAllTags() : void 0) || {});
        }

        allProperties() {
          var ref;
          return this.addProperties(((ref = this.parent) != null ? ref.allProperties() : void 0) || {});
        }

        allTags() {
          return _.keys(this.addAllTags());
        }

        parts() {
          var m, ref, ref1, ref2, ref3, ref4;
          m = this.text.match(headlineRE);
          return {
            level: ((ref = m[HL_LEVEL]) != null ? ref : '').trim().length,
            stars: (ref1 = m[HL_LEVEL]) != null ? ref1 : '',
            todo: (ref2 = m[HL_TODO]) != null ? ref2 : '',
            priority: (ref3 = m[HL_PRIORITY]) != null ? ref3 : '',
            text: m[HL_TEXT],
            tags: (ref4 = m[HL_TAGS]) != null ? ref4 : ''
          };
        }

        partOffsets() {
          var addPart, m, pos, ref, ref1, ref2, ref3, ret;
          m = this.text.match(headlineRE);
          pos = 0;
          ret = {};
          addPart = function(name, text) {
            ret[name] = {
              start: pos,
              end: pos + text.length
            };
            return pos += text.length;
          };
          addPart('stars', (ref = m[HL_LEVEL]) != null ? ref : '');
          addPart('todo', (ref1 = m[HL_TODO]) != null ? ref1 : '');
          addPart('priority', (ref2 = m[HL_PRIORITY]) != null ? ref2 : '');
          addPart('text', m[HL_TEXT]);
          addPart('tags', (ref3 = m[HL_TAGS]) != null ? ref3 : '');
          return ret;
        }

      };

      Headline.prototype.block = true;

      Headline.prototype.type = 'headline';

      Headline.prototype.scan = Node.prototype.scanWithChildren;

      return Headline;

    }).call(this);
    Fragment = (function() {
      class Fragment extends Node {
        //constructor: (@offset, @children)-> @text = ''
        constructor(offset1, children1) {
          super();
          this.offset = offset1;
          this.children = children1;
          this.text = '';
        }

        count() {
          var count, i, len, node, ref;
          count = 1;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            node = ref[i];
            count += node.count();
          }
          return count;
        }

        end() {
          var lastChild;
          if (this.children.length) {
            lastChild = this.children[this.children.length - 1];
            return lastChild.offset + lastChild.length();
          } else {
            return super.end();
          }
        }

        length() {
          return this.end() - this.offset;
        }

        jsonDef() {
          var c;
          return {
            type: this.type,
            offset: this.offset,
            children: (function() {
              var i, len, ref, results;
              ref = this.children;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                c = ref[i];
                results.push(c.toJsonObject());
              }
              return results;
            }).call(this)
          };
        }

        allText() {
          var c;
          return this.text + ((function() {
            var i, len, ref, results;
            ref = this.children;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              c = ref[i];
              results.push(c.allText());
            }
            return results;
          }).call(this)).join('');
        }

        findNodeAt(pos) {
          var child, i, len, ref, res;
          if (pos < this.offset || this.offset + this.length() < pos) {
            return null;
          } else if (pos < this.offset + this.text.length) {
            return this;
          } else {
            ref = this.children;
            // could binary search this
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (res = child.findNodeAt(pos)) {
                return res;
              }
            }
            return null;
          }
        }

        linkNodes() {
          return this.linkChildren();
        }

        linkChild(child) {
          child.fragment = this;
          return super.linkChild(child);
        }

        linkTo(parent) {
          var c, i, len, ref, results;
          if (this.children.length) {
            this.children[0].prev = this.prev;
            this.children[this.children.length - 1].next = this.next;
            ref = this.children;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              c = ref[i];
              results.push(c.linkTo(parent));
            }
            return results;
          }
        }

      };

      Fragment.prototype.block = true;

      Fragment.prototype.type = 'fragment';

      return Fragment;

    }).call(this);
    Meat = (function() {
      class Meat extends Node {
        constructor(text1, offset1) {
          super();
          this.text = text1;
          this.offset = offset1;
        }

        lowerThan(l) {
          return true;
        }

        jsonDef() {
          return {
            type: this.type,
            text: this.text,
            offset: this.offset
          };
        }

        inNewMeat() {
          var cur, i, len, m, meat, t;
          meat = [];
          cur = this;
          while (cur && !(cur instanceof Headline || inListItem(cur))) {
            meat.push(cur);
            cur = cur.getPrecedingNode();
          }
          meat.reverse();
          t = '';
          for (i = 0, len = meat.length; i < len; i++) {
            m = meat[i];
            t += m.allText();
          }
          return t.match(meatStart);
        }

      };

      Meat.prototype.type = 'meat';

      return Meat;

    }).call(this);
    inListItem = function(org) {
      var ref;
      return org && (org instanceof ListItem || inListItem((ref = org.fragment) != null ? ref : org.parent));
    };
    meatStart = /^\S|\n\n\S/;
    markupTypes = {
      '*': 'bold',
      '/': 'italic',
      '_': 'underline',
      '=': 'verbatim',
      '~': 'code',
      '+': 'strikethrough'
    };
    SimpleMarkup = (function() {
      //* bold, / italic, _ underline, = verbatim, ~ code, + strikethrough
      class SimpleMarkup extends Meat {
        constructor(text1, offset1, children1) {
          super();
          this.text = text1;
          this.offset = offset1;
          this.children = children1;
          this.markupType = markupTypes[this.text[0]];
        }

        count() {
          var count, i, len, node, ref;
          count = 1;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            node = ref[i];
            count += node.count();
          }
          return count;
        }

        linkNodes() {
          return this.linkChildren();
        }

        jsonDef() {
          var c;
          return {
            type: this.type,
            text: this.text,
            offset: this.offset,
            markupType: this.markupType,
            children: (function() {
              var i, len, ref, results;
              ref = this.children;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                c = ref[i];
                results.push(c.toJsonObject());
              }
              return results;
            }).call(this)
          };
        }

      };

      SimpleMarkup.prototype.type = 'simple';

      SimpleMarkup.prototype.scan = Node.prototype.scanWithChildren;

      return SimpleMarkup;

    }).call(this);
    Link = (function() {
      class Link extends Meat {
        constructor(text1, offset1, path, children1) {
          super();
          this.text = text1;
          this.offset = offset1;
          this.path = path;
          this.children = children1;
        }

        count() {
          var count, i, len, node, ref;
          count = 1;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            node = ref[i];
            count += node.count();
          }
          return count;
        }

        jsonDef() {
          var c;
          return {
            type: this.type,
            text: this.text,
            offset: this.offset,
            path: this.path,
            children: (function() {
              var i, len, ref, results;
              ref = this.children;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                c = ref[i];
                results.push(c.toJsonObject());
              }
              return results;
            }).call(this)
          };
        }

        isImage() {
          return this.path.match(imagePathRE);
        }

        isLeisure() {
          return this.path.match(leisurePathRE);
        }

        descriptionText() {
          var child;
          return ((function() {
            var i, len, ref, results;
            ref = this.children;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              results.push(child.allText());
            }
            return results;
          }).call(this)).join(' ');
        }

      };

      Link.prototype.type = 'link';

      Link.prototype.scan = Node.prototype.scanWithChildren;

      return Link;

    }).call(this);
    ListItem = (function() {
      class ListItem extends Meat {
        constructor(text, offset, level1, checked, contentOffset1, children1) {
          super(text, offset);
          this.level = level1;
          this.checked = checked;
          this.contentOffset = contentOffset1;
          this.children = children1;
          this.text = text;
          this.offset = offset;
        }

        count() {
          var count, i, len, node, ref;
          count = 1;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            node = ref[i];
            count += node.count();
          }
          return count;
        }

        linkNodes() {
          return this.linkChildren();
        }

        jsonDef() {
          var child, obj;
          obj = {
            type: this.type,
            text: this.text,
            level: this.level,
            offset: this.offset,
            contentOffset: this.contentOffset,
            children: (function() {
              var i, len, ref, results;
              ref = this.children;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                results.push(child.toJsonObject());
              }
              return results;
            }).call(this)
          };
          if (this.checked != null) {
            obj.checked = this.checked;
          }
          return obj;
        }

        getParent() {
          var li;
          if (this.level === 0) {
            null;
          }
          li = this;
          while (li = li.getPreviousListItem()) {
            if (li.level < this.level) {
              return li;
            }
          }
        }

        getPreviousListItem() {
          var cur, parent, ref;
          parent = this.fragment || this.parent;
          cur = this;
          while (cur = cur.getPrecedingNode()) {
            if (!(parent.contains(cur)) || cur.inNewMeat()) {
              return null;
            }
            if (((ref = cur.fragment) != null ? ref : cur.parent) === parent && cur instanceof ListItem) {
              return cur;
            }
          }
          return null;
        }

        getNextListItem() {
          var cur, parent, ref;
          parent = this.fragment || this.parent;
          cur = this;
          while (cur = cur.getFollowingNode()) {
            if (!(parent.contains(cur)) || cur.inNewMeat()) {
              return null;
            }
            if (((ref = cur.fragment) != null ? ref : cur.parent) === parent && cur instanceof ListItem) {
              return cur;
            }
          }
          return null;
        }

        inNewMeat() {
          return true;
        }

      };

      ListItem.prototype.type = 'list';

      ListItem.prototype.scan = Node.prototype.scanWithChildren;

      return ListItem;

    }).call(this);
    Drawer = (function() {
      class Drawer extends Meat {
        constructor(text, offset, name1, contentPos1, endPos) {
          super(text, offset);
          this.name = name1;
          this.contentPos = contentPos1;
          this.endPos = endPos;
          this.text = text;
          this.offset = offset;
        }

        jsonDef() {
          return {
            type: this.type,
            name: this.name,
            text: this.text,
            offset: this.offset,
            contentPos: this.contentPos,
            endPos: this.endPos
          };
        }

        leading() {
          return this.text.substring(0, this.contentPos);
        }

        content() {
          return this.text.substring(this.contentPos, this.endPos);
        }

        trailing() {
          return this.text.substring(this.endPos);
        }

        isProperties() {
          return this.name.toLowerCase() === 'properties';
        }

        properties() {
          var m, props, ref;
          props = {};
          if (this.isProperties()) {
            while (m = propertyRE.exec(this.text.substring(this.contentPos, this.endPos))) {
              props[m[PROPERTY_KEY]] = ((ref = m[PROPERTY_VALUE]) != null ? ref : '').trim();
            }
          }
          return props;
        }

        //name: ->
        //  n = @leading().trim()
        //  n.substring 1, n.length - 1
        linkTo(node) {
          super.linkTo(node);
          if (this.isProperties()) {
            if (!(node instanceof Headline) && !(node instanceof Fragment)) {
              return console.log("WARNING: Drawer's parent is not a Headline'");
            } else {
              if (!node.properties) {
                node.properties = {};
              }
              return Object.assign(node.properties, this.properties());
            }
          }
        }

      };

      Drawer.prototype.type = 'drawer';

      return Drawer;

    }).call(this);
    Example = (function() {
      class Example extends Meat {
        constructor(text1, offset1, contentPos1, contentLength1) {
          super();
          this.text = text1;
          this.offset = offset1;
          this.contentPos = contentPos1;
          this.contentLength = contentLength1;
        }

        jsonDef() {
          return {
            type: this.type,
            text: this.text,
            offset: this.offset,
            contentPos: this.contentPos,
            contentLength: this.contentLength
          };
        }

        exampleText() {
          return this.text.substring(this.contentPos, this.contentPos + this.contentLength);
        }

      };

      Example.prototype.block = true;

      Example.prototype.type = 'example';

      return Example;

    }).call(this);
    Keyword = (function() {
      class Keyword extends Meat {
        constructor(text, offset, name1, info1) {
          super(text, offset);
          this.name = name1;
          this.info = info1;
          this.text = text;
          this.offset = offset;
        }

        jsonDef() {
          return {
            type: this.type,
            text: this.text,
            offset: this.offset,
            name: this.name,
            info: this.info
          };
        }

        attributes() {
          return parseCodeAttributes(this.info);
        }

        lead() {
          return _(this.info.split(keywordPropertyRE)).first();
        }

      };

      Keyword.prototype.block = true;

      Keyword.prototype.type = 'keyword';

      return Keyword;

    }).call(this);
    parseCodeAttributes = function(attrText) {
      var attr, i, k, len, o, ref, v;
      o = _(attrText.split(keywordPropertyRE)).drop(1).map(function(str) {
        return str.trim();
      });
      if (o.isEmpty()) {
        return null;
      } else {
        attr = {};
        ref = o.chunk(2).toArray();
        for (i = 0, len = ref.length; i < len; i++) {
          [k, v] = ref[i];
          if (attr[k]) {
            if (!(attr[k] instanceof Array)) {
              attr[k] = [attr[k]];
            }
            attr[k].push(v);
          } else {
            attr[k] = v;
          }
        }
        return attr;
      }
    };
    Source = (function() {
      class Source extends Keyword {
        constructor(text, offset, name, info, infoPos1, content, contentPos1) {
          super(text, offset, name, info);
          this.infoPos = infoPos1;
          this.content = content;
          this.contentPos = contentPos1;
          this.text = text;
          this.offset = offset;
          this.name = name;
          this.Info = info;
        }

        getLanguage() {
          var ref;
          return (ref = this.lead()) != null ? ref.trim().toLowerCase() : void 0;
        }

        jsonDef() {
          return {
            type: this.type,
            text: this.text,
            offset: this.offset,
            name: this.name,
            info: this.info,
            infoPos: this.infoPos,
            content: this.content,
            contentPos: this.contentPos,
            contentLength: this.content.length
          };
        }

      };

      Source.prototype.type = 'source';

      return Source;

    }).call(this);
    HTML = (function() {
      class HTML extends Keyword {
        constructor(text, offset, name, contentPos1, contentLength1, info) {
          super(text, offset, name, info);
          this.contentPos = contentPos1;
          this.contentLength = contentLength1;
          this.text = text;
          this.offset = offset;
          this.name = name;
          this.info = info;
        }

        leading() {
          return this.text.substring(0, this.contentPos);
        }

        trailing() {
          return this.text.substring(this.contentPos + this.contentLength);
        }

        content() {
          return this.text.substring(this.contentPos, this.contentPos + this.contentLength);
        }

        jsonDef() {
          return {
            type: this.type,
            info: this.info || '',
            text: this.text,
            offset: this.offset,
            contentPos: this.contentPos,
            contentLength: this.contentLength
          };
        }

      };

      HTML.prototype.type = 'html';

      return HTML;

    }).call(this);
    Results = (function() {
      class Results extends Keyword {
        constructor(text, offset, name, contentPos) {
          super(text, offset, name);
          this.text = text;
          this.offset = offset;
          this.name = name;
          this.contentPos = contentPos;
        }

        content() {
          return this.text.substring(this.contentPos);
        }

        jsonDef() {
          return {
            type: this.type,
            text: this.text,
            offset: this.offset,
            name: this.name,
            contentPos: this.contentPos
          };
        }

      };

      Results.prototype.type = 'results';

      return Results;

    }).call(this);
    AttrHtml = (function() {
      class AttrHtml extends Keyword {
        constructor(text, offset, name, contentPos) {
          super(text, offset, name);
          this.text = text;
          this.offest = offset;
          this.name = name;
          this.contentPos = contentPos;
        }

        jsonDef() {
          return {
            type: this.type,
            text: this.text,
            offset: this.offset,
            name: this.name,
            contentPos: this.contentPos
          };
        }

      };

      AttrHtml.prototype.type = 'attr';

      return AttrHtml;

    }).call(this);
    UnknownDeclaration = (function() {
      class UnknownDeclaration extends Meat {
        constructor(text1, offset1) {
          super();
          this.text = text1;
          this.offset = offset1;
        }

        jsonDef() {
          return {
            type: this.type,
            text: this.text,
            offset: this.offset
          };
        }

      };

      UnknownDeclaration.prototype.type = 'unknown';

      return UnknownDeclaration;

    }).call(this);
    nextOrgNode = function(node) {
      var up;
      up = false;
      while (node) {
        if (node.children && !up && node.children.length) {
          return node.children[0];
        } else if (node.next) {
          return node.next;
        } else {
          up = true;
          node = node.parent;
        }
      }
      return null;
    };
    
    // Parse the content of an orgmode file

    parseOrgMode = function(text, offset, useFragment) {
      var res, rest;
      if (text instanceof Node) {
        return text;
      } else {
        [res, rest] = parseHeadline('', offset != null ? offset : 0, 0, void 0, void 0, void 0, text, text.length);
        if (rest.length) {
          throw new Error(`Text left after parsing: ${rest}`);
        }
        if (useFragment) {
          if (res.children.length === 1) {
            res = res.children[0];
          } else if (res.children.length > 1) {
            res = new Fragment(res.offset, res.children);
          }
        }
        return res.linkNodes();
      }
    };
    parseHeadline = function(text, offset, level, todo, priority, tags, rest, totalLen) {
      var child, children, oldRest, originalRest;
      children = [];
      originalRest = rest;
      while (true) {
        oldRest = rest;
        [child, rest] = parseOrgChunk(rest, originalRest.length - rest.length + offset, level);
        if (!child) {
          break;
        }
        if (child.lowerThan(level)) {
          while (child) {
            children.push(child);
            child = child.next;
          }
        } else {
          rest = oldRest;
        }
      }
      return [new Headline(text, level, todo, priority, tags || '', children, offset), rest];
    };
    parseTags = function(text) {
      var i, len, ref, t, tagArray;
      tagArray = [];
      ref = (text ? text.split(':') : []);
      for (i = 0, len = ref.length; i < len; i++) {
        t = ref[i];
        if (t) {
          tagArray.push(t);
        }
      }
      return tagArray;
    };
    fullLine = function(match, text) {
      return text.substring(match.index, match.index + match[0].length + (text[match.index + match[0].length] === '\n' ? 1 : 0));
    };
    parseOrgChunk = function(text, offset, level) {
      var l, line, m, meat, meatLen, ref, simple;
      if (!text) {
        return [null, text];
      } else {
        m = text.match(headlineRE);
        simple = ((ref = text.match(simpleRE)) != null ? ref.index : void 0) === 0;
        if ((m != null ? m.index : void 0) === 0 && !simple) {
          if (m[HL_LEVEL].trim().length <= level) {
            return [null, text];
          } else {
            line = fullLine(m, text);
            return parseHeadline(line, offset, m[HL_LEVEL].trim().length, m[HL_TODO], m[HL_PRIORITY], m[HL_TAGS], text.substring(line.length), offset + text.length);
          }
        } else {
          if ((m != null ? m.index : void 0) === 0 && simple && (l = text.indexOf('\n')) > -1 && (m = text.substring(l).match(headlineRE))) {
            meatLen = m.index + l;
          } else {
            meatLen = m && (m.index > 0 || !simple) ? m.index : text.length;
          }
          meat = text.substring(0, meatLen);
          return parseMeat(meat, offset, text.substring(meatLen), false);
        }
      }
    };
    MeatParser = class MeatParser {
      constructor() {}

      checkPat(pattern, cont) {
        var line, match;
        if (!this.result && (match = this.meat.match(pattern))) {
          if (match.index === 0) {
            line = fullLine(match, this.meat);
            return this.result = cont(line, this.meat.substring(line.length) + this.rest, match);
          } else {
            return this.minLen = Math.min(this.minLen, match.index);
          }
        }
      }

      parse(meat, offset, rest, singleLine) {
        var m, meatText, newline;
        this.meat = meat;
        this.rest = rest;
        this.minLen = meat.length + offset;
        this.result = null;
        if (!this.singleLine) {
          this.checkPat(resultsRE, function(line, newRest) {
            return parseResults(line, offset, newRest);
          });
          this.checkPat(attrHtmlRE, function(line, newRest) {
            return parseAttr(line, offset, newRest);
          });
          this.checkPat(srcStartRE, function(line, newRest, srcStart) {
            return parseSrcBlock(line, offset, srcStart[SRC_INFO], srcStart[SRC_BOILERPLATE].length, newRest);
          });
          this.checkPat(htmlStartRE, function(line, newRest, html) {
            return parseHtmlBlock(line, offset, newRest, html);
          });
          this.checkPat(keywordRE, function(line, newRest, keyword) {
            return parseKeyword(keyword, line, offset, keyword[KW_NAME], keyword[KW_INFO], newRest);
          });
          this.checkPat(listRE, function(line, newRest, list) {
            var ref, ref1;
            return parseList(list, line, offset, (ref = (ref1 = list[LIST_LEVEL]) != null ? ref1.length : void 0) != null ? ref : 0, list[LIST_CHECK_VALUE], list[LIST_INFO], newRest);
          });
          this.checkPat(exampleStartRE, function(line, newRest, start) {
            var end;
            if ((end = newRest.match(declRE)) && end[0].match(exampleEndRE)) {
              return parseExample(line, offset, start, end, newRest);
            }
          });
          this.checkPat(drawerRE, function(line, newRest, drawer) {
            var end;
            if (end = newRest.match(endRE)) {
              return parseDrawer(line, drawer[DRAWER_NAME], offset, end, newRest);
            }
          });
          this.checkPat(declRE, function(line, newRest) {
            return parseUnknown(line, offset, newRest);
          });
        }
        if (this.result) {
          return this.result;
        } else {
          this.checkPat(simpleRE, function(line, newRest, simple) {
            var child, children, inside, insideOffset;
            inside = simple[0].substring(1, simple[0].length - 1);
            insideOffset = offset + 1;
            children = [];
            while (inside) {
              [child, inside] = parseMeat(inside, insideOffset, '', true);
              while (child) {
                children.push(child);
                insideOffset = child.offset + child.text.length;
                child = child.next;
              }
            }
            return new SimpleMarkup(simple[0], offset, children);
          });
          this.checkPat(linkRE, function(line, newRest, link) {
            var child, children, inside, insideOffset;
            inside = link[LINK_DESCRIPTION];
            insideOffset = offset + link[LINK_HEAD].length;
            children = [];
            while (inside) {
              [child, inside] = parseMeat(inside, insideOffset, '', true);
              while (child) {
                children.push(child);
                insideOffset = child.offset + child.text.length;
                child = child.next;
              }
            }
            return new Link(link[0], offset, link[LINK_INFO], children);
          });
          if (!this.result) {
            if (newline = meat.substring(0, 2) === '\n\n') {
              meatText = meat.substring(2);
            }
            meatText = meat.substring(0, this.minLen);
            if (m = meatText.match(lineBreakPat)) {
              meatText = meat.substring(0, m.index);
            }
            if (newline) {
              meatText = '\n\n' + meatText;
            }
            this.result = new Meat(meatText, offset);
          }
          return parseRestOfMeat(this.result, meat.substring(this.result.text.length), rest);
        }
      }

    };
    lineBreakPat = /\n\n/;
    parseMeat = function(meat, offset, rest, singleLine) {
      return new MeatParser().parse(meat, offset, rest, singleLine);
    };
    parseRestOfMeat = function(node, meat, rest) {
      var node2;
      if (meat && node.text[node.text.length - 1] !== '\n') {
        [node2, rest] = parseMeat(meat, node.offset + node.allText().length, rest, true);
        node.next = node2;
        return [node, rest];
      } else {
        return [node, meat + rest];
      }
    };
    parseResults = function(text, offset, rest) {
      var lines, m, oldRest, ref;
      oldRest = rest;
      while (m = rest.match(resultsLineRE)) {
        rest = rest.substring(m[0].length);
      }
      if (oldRest === rest && rest.length && !((ref = rest[0]) === '#' || ref === '\n')) {
        rest = rest.substring(((m = rest.match(/\n/)) ? m.index + 1 : rest.length));
      }
      lines = oldRest.substring(0, oldRest.length - rest.length);
      return [new Results(text + lines, offset, text.match(resultsRE)[RES_NAME], text.length), rest];
    };
    parseAttr = function(text, offset, rest) {
      var lines, m, oldRest;
      oldRest = rest;
      while (m = rest.match(attrHrmlLineRE)) {
        rest = rest.substring(m[0].length);
      }
      lines = oldRest.substring(0, oldRest.length - rest.length);
      return [new AttrHtml(text + lines, offset, text.match(attrHtmlRE)[ATTR_NAME], text.length), rest];
    };
    parseDrawer = function(text, name, offset, end, rest) {
      var pos;
      pos = end.index + (fullLine(end, rest)).length;
      return [new Drawer(text + rest.substring(0, pos), offset, name, text.length, text.length + end.index), rest.substring(pos)];
    };
    parseKeyword = function(match, text, offset, name, info, rest) {
      return [new Keyword(text, offset, name, text.substring(match[KW_BOILERPLATE].length)), rest];
    };
    parseExample = function(startLine, offset, start, end, rest) {
      var contentLength, contentPos, lastLine, newRest, text;
      lastLine = fullLine(end, rest);
      newRest = rest.substring(end.index + lastLine.length);
      contentPos = startLine.length;
      contentLength = end.index;
      text = startLine + rest.substring(0, rest.length - newRest.length);
      return [new Example(text, offset, contentPos, contentLength), newRest];
    };
    parseSrcBlock = function(text, offset, info, infoPos, rest) {
      var end, endLine, line, otherSrcStart;
      end = rest.match(srcEndRE);
      otherSrcStart = rest.match(srcStartRE);
      if (!end || (otherSrcStart && otherSrcStart.index < end.index)) {
        line = text.match(/^.*\n/);
        if (!line) {
          line = [text];
        }
        return [new Meat(line[0]), text.substring(line[0].length) + rest];
      } else {
        endLine = fullLine(end, rest);
        return [new Source(text + rest.substring(0, end.index + endLine.length), offset, text.match(srcStartRE)[SRC_NAME], info, infoPos, rest.substring(0, end.index), text.length), rest.substring(end.index + endLine.length)];
      }
    };
    parseHtmlBlock = function(text, offset, rest, match) {
      var end, endLine, line, otherHtmlStart;
      end = rest.match(htmlEndRE);
      otherHtmlStart = rest.match(htmlStartRE);
      line = text.match(/^.*\n/);
      if (!line) {
        line = [text];
      }
      if (!end || (otherHtmlStart && otherHtmlStart.index < end.index)) {
        return [new Meat(line[0]), text.substring(line[0].length) + rest];
      } else {
        endLine = fullLine(end, rest);
        return [new HTML(text + rest.substring(0, end.index + endLine.length), offset, match[HTML_START_NAME], line[0].length, text.length + end.index - line[0].length, match[HTML_INFO]), rest.substring(end.index + endLine.length)];
      }
    };
    parseList = function(match, text, offset, level, check, info, rest) {
      var children, contentOffset, inside, insideOffset, node;
      contentOffset = listContentOffset(match);
      insideOffset = offset + contentOffset;
      inside = text.substring(contentOffset);
      children = [];
      while (inside) {
        [node, inside] = parseMeat(inside, insideOffset, '', true);
        while (node) {
          children.push(node);
          insideOffset += node.allText().length;
          node = node.next;
        }
      }
      return [new ListItem(text, offset, level, check === 'X' || (check === ' ' ? false : null), contentOffset, children), rest];
    };
    parseUnknown = function(line, offset, rest) {
      return [new UnknownDeclaration(line, offset), rest];
    };
    listContentOffset = function(match) {
      var ref, ref1;
      return match[LIST_LEVEL].length + match[LIST_BOILERPLATE].length + ((ref = (ref1 = match[LIST_CHECK]) != null ? ref1.length : void 0) != null ? ref : 0);
    };
    markupText = function(text) {};
    return {parseOrgMode, parseMeat, Node, Headline, Fragment, Meat, Keyword, Source, HTML, Results, resultsRE, ListItem, SimpleMarkup, Link, UnknownDeclaration, Drawer, Example, drawerRE, headlineRE, HL_LEVEL, HL_TODO, HL_PRIORITY, HL_TEXT, HL_TAGS, parseTags, matchLine, keywordRE, KW_BOILERPLATE, KW_NAME, KW_INFO, srcStartRE, SRC_BOILERPLATE, SRC_INFO, nextOrgNode, AttrHtml, parseCodeAttributes};
  });

}).call(this);

//# sourceMappingURL=org.js.map

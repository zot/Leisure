// Generated by CoffeeScript 2.4.1
(function() {
  // Advice
  // ======
  // Copyright (C) 2015, Bill Burdick, Roy Riggs, TEAM CTHULHU

  // Licensed with ZLIB license (see "[License](#license)", below).

  // Advice is part of Leisure project.  You can find it on
  // [Github](https://github.com/zot/Leisure).

  // Licensed with ZLIB license.
  // =============================

  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.

  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:

  // 1. The origin of this software must not be misrepresented; you must not
  // claim that you wrote the original software. If you use this software
  // in a product, an acknowledgment in the product documentation would be
  // appreciated but is not required.

  // 2. Altered source versions must be plainly marked as such, and must not be
  // misrepresented as being the original software.

  // 3. This notice may not be removed or altered from any source distribution.

  // Code
  // ====

  // <a id='Method_Advice'></a>
  // Method Advice
  define([], function() {
    'use strict';
    var Advice, advise, afterMethod, beforeMethod, callOriginal, changeAdvice, unadvise;
    (function() {      // changeAdvice(object, flag, advice) is the main API method.  Using
      // advice will add an "ADVICE" property to object.

      // - object is the object that has methods you want to override (numbers won't work)
      // - flag turns on and off the advice
      // - advice is an object with a property for each method you want to override
      //   - each property contains another object with a property, which labels the advice
      //   - the property's value should be the advice (if you're adding advice)

      // Calling changeAdvice with true will preserve the original methods and
      // wrap them with your advice

      // Calling changeAdvice with false will restore the original methods.

      // When you specify advice, you can use beforeMethod and afterMethod to
      // create the advice or you can just provide a function that takes the
      // parent function and returns the function to run in its place.
      return changeAdvice(object, true, {
        setName: {
          monitorName: afterMethod(function(newName) {
            return console.log(`Set name ${newName}`);
          })
        },
        setOwner: {
          diag: function(parent) {
            return function(newOwner) {
              var err;
              try {
                return parent(newOwner);
              } catch (error) {
                err = error;
                dispayError(err);
                throw err;
              }
            };
          }
        }
      });
    });
    (function() {      // Here's that same example in JavaScript with the functions declared
      // separately for clarity.  Keep in mind that these functions will be
      // used as methods on object, so you can use "this" in them.
      return 
        function monitorName(newName) {
          console.log("Set name " + newName);
        }
        function diagSetOwner(parent) {
          return function (newOwner) {
            try {
              return parent(newOwner);
            } catch (err) {
              dispayError(err);
              throw err;
            }
          };
        }

        changeAdvice(object, true, {
          setName: {monitorName: afterMethod(monitorName)},
          setOwner: {diag: diagSetOwner}
        });
      ;
    });
    changeAdvice = function(object, flag, advice) {
      if (flag) {
        return advise(object, advice);
      } else {
        return unadvise(object, advice);
      }
    };
    // beforeMethod(def) takes a function to run before the method you are
    // advising.  It will run as a method on the object and take the same
    // arguments as the original method.  After it runs, the original method
    // will run and its result will be returned (so you can return whatever
    // you want from your definition).
    beforeMethod = function(def) {
      return function(parent) {
        return function(...args) {
          def.apply(this, args);
          return parent.apply(this, args);
        };
      };
    };
    // afterMethod(def) takes a function to run after the method you are
    // advising.  It will run as a method on the object and take the same
    // arguments as the original method.  The original method will run, then
    // your supplied function will run, then the return value from the
    // original method will be returned (so you can return whatever you want
    // from your definition).
    afterMethod = function(def) {
      return function(parent) {
        return function(...args) {
          var r;
          r = parent.apply(this, args);
          def.apply(this, args);
          return r;
        };
      };
    };
    // Low Level Code
    // ==============
    Advice = class Advice {
      constructor(target, disabled) {
        this.target = target;
        this.originals = {};
        this.adviceOrder = {};
        this.advice = {};
        if (!disabled) {
          this.enable();
        }
      }

      enable(method) {
        var i, len, ref;
        if (!this.enabled) {
          if (method) {
            this.installAdviceHandler(method);
          } else {
            if (!this.target.ADVICE) {
              this.target.ADVICE = this;
            } else if (this.target.ADVICE !== this) {
              throw new Error("Attempt to install advice on advised object");
            }
            ref = this.advice;
            for (i = 0, len = ref.length; i < len; i++) {
              method = ref[i];
              this.installAdviceHandler(method);
            }
          }
          this.enabled = true;
          return this;
        }
      }

      disable(method) {
        var i, len, ref;
        if (this.enabled) {
          if (method) {
            this.target[method] = this.originals[method];
            delete this.originals[method];
            if (_.isEmpty(this.originals)) {
              this.disable();
            }
          } else {
            ref = this.advice;
            for (i = 0, len = ref.length; i < len; i++) {
              method = ref[i];
              this.target[method] = this.originals[method];
            }
            this.originals = {};
            delete this.target.ADVICE;
            this.enabled = false;
          }
          return this;
        }
      }

      advise(method, name, def) {
        var key;
        key = `${method}-${name}`;
        this.advice[key] = def;
        if (!this.adviceOrder[method]) {
          this.adviceOrder[method] = [];
        }
        this.adviceOrder[method].push(key);
        if (this.enabled) {
          this.installAdviceHandler(method);
        }
        return this;
      }

      unadvise(method, name) {
        var i, key, len, ref, ref1, ref2;
        if (!name) {
          ref1 = (ref = this.adviceOrder[method]) != null ? ref : [];
          for (i = 0, len = ref1.length; i < len; i++) {
            name = ref1[i];
            this.removeAdvice(method, name);
          }
        } else {
          key = `${method}-${name}`;
          if (((ref2 = this.adviceOrder[method]) != null ? ref2.length : void 0) === 1) {
            this.disable(method);
            delete this.adviceOrder[method];
          } else {
            _.remove(this.adviceOrder, function(x) {
              return x === key;
            });
          }
          delete this.advice[key];
        }
        return this;
      }

      installAdviceHandler(method) {
        if (!this.originals[method]) {
          this.originals[method] = this.target[method];
          return this.target[method] = (...args) => {
            return this.callAdvice(this.adviceOrder[method].length - 1, this.adviceOrder[method], method, args);
          };
        }
      }

      callAdvice(index, order, method, args) {
        var func;
        func = index < 0 ? this.originals[method] : this.advice[order[index]]((...args) => {
          return this.callAdvice(index - 1, order, method, args);
        });
        return func.apply(this.target, args);
      }

    };
    advise = function(object, method, name, def) {
      var advice, meth, ref, results;
      if (typeof method === 'object') {
        results = [];
        for (meth in method) {
          advice = method[meth];
          results.push((function() {
            var results1;
            results1 = [];
            for (name in advice) {
              def = advice[name];
              results1.push(advise(object, meth, name, def));
            }
            return results1;
          })());
        }
        return results;
      } else {
        return ((ref = object.ADVICE) != null ? ref : new Advice(object)).advise(method, name, def);
      }
    };
    unadvise = function(object, method, name) {
      var advice, def, meth, ref, results;
      if (typeof method === 'object') {
        results = [];
        for (meth in method) {
          advice = method[meth];
          results.push((function() {
            var results1;
            results1 = [];
            for (name in advice) {
              def = advice[name];
              results1.push(unadvise(object, meth, name));
            }
            return results1;
          })());
        }
        return results;
      } else {
        return (ref = object.ADVICE) != null ? ref.unadvise(method, name) : void 0;
      }
    };
    callOriginal = function(object, method, ...args) {
      var ref, ref1, ref2;
      return ((ref = (ref1 = object.ADVICE) != null ? (ref2 = ref1.originals) != null ? ref2[method] : void 0 : void 0) != null ? ref : object[method]).apply(object, args);
    };
    return {changeAdvice, beforeMethod, afterMethod, advise, unadvise, callOriginal};
  });

}).call(this);

//# sourceMappingURL=advice.js.map
